{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/axios/index.js","node_modules/axios/lib/adapters/xhr.js","node_modules/axios/lib/axios.js","node_modules/axios/lib/cancel/Cancel.js","node_modules/axios/lib/cancel/CancelToken.js","node_modules/axios/lib/cancel/isCancel.js","node_modules/axios/lib/core/Axios.js","node_modules/axios/lib/core/InterceptorManager.js","node_modules/axios/lib/core/buildFullPath.js","node_modules/axios/lib/core/createError.js","node_modules/axios/lib/core/dispatchRequest.js","node_modules/axios/lib/core/enhanceError.js","node_modules/axios/lib/core/mergeConfig.js","node_modules/axios/lib/core/settle.js","node_modules/axios/lib/core/transformData.js","node_modules/axios/lib/defaults.js","node_modules/axios/lib/helpers/bind.js","node_modules/axios/lib/helpers/buildURL.js","node_modules/axios/lib/helpers/combineURLs.js","node_modules/axios/lib/helpers/cookies.js","node_modules/axios/lib/helpers/isAbsoluteURL.js","node_modules/axios/lib/helpers/isURLSameOrigin.js","node_modules/axios/lib/helpers/normalizeHeaderName.js","node_modules/axios/lib/helpers/parseHeaders.js","node_modules/axios/lib/helpers/spread.js","node_modules/axios/lib/utils.js","node_modules/debug/node_modules/ms/index.js","node_modules/debug/src/browser.js","node_modules/debug/src/common.js","node_modules/process/browser.js","node_modules/superstruct/lib/index.cjs","src/entities/account.js","src/entities/accountHolder.js","src/entities/address.js","src/entities/card.js","src/entities/feedItem.js","src/entities/identity.js","src/entities/mandate.js","src/entities/oauth.js","src/entities/payee.js","src/entities/payment.js","src/entities/savingsGoal.js","src/starling.js","src/utils/http.js","src/utils/validator.js"],"names":[],"mappings":"AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACllDA,MAAM,GAAG,GAAG,uBAAM,0BAAN,CAAZ;AAEA;;;;MAGM,O;AACJ;;;;AAIA,qBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;kCAMa,U,EAAY;AACvB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFuB,0BAGS,UAHT;AAAA,YAGf,MAHe,eAGf,MAHe;AAAA,YAGP,WAHO,eAGP,WAHO;AAKvB,YAAM,GAAG,aAAM,MAAN,qBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;4CAOuB,U,EAAY;AACjC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,uCAAuC,CAAC,UAAD,CAAvC;AAFiC,2BAGW,UAHX;AAAA,YAGzB,MAHyB,gBAGzB,MAHyB;AAAA,YAGjB,WAHiB,gBAGjB,WAHiB;AAAA,YAGJ,UAHI,gBAGJ,UAHI;AAKjC,YAAM,GAAG,aAAM,MAAN,8BAAgC,UAAhC,iBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;wCAOmB,U,EAAY;AAC7B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,mCAAmC,CAAC,UAAD,CAAnC;AAF6B,2BAGe,UAHf;AAAA,YAGrB,MAHqB,gBAGrB,MAHqB;AAAA,YAGb,WAHa,gBAGb,WAHa;AAAA,YAGA,UAHA,gBAGA,UAHA;AAK7B,YAAM,GAAG,aAAM,MAAN,8BAAgC,UAAhC,aAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;6CAQwB,U,EAAY;AAClC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,wCAAwC,CAAC,UAAD,CAAxC;AAFkC,2BAGoC,UAHpC;AAAA,YAG1B,MAH0B,gBAG1B,MAH0B;AAAA,YAGlB,WAHkB,gBAGlB,WAHkB;AAAA,YAGL,UAHK,gBAGL,UAHK;AAAA,YAGO,wBAHP,gBAGO,wBAHP;AAKlC,YAAM,GAAG,aAAM,MAAN,8BAAgC,UAAhC,2BAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf,CAHE;AAIX,UAAA,MAAM,EAAE;AACN,YAAA,wBAAwB,EAAxB;AADM;AAJG,SAAN,CAAP;AAQD;AAED;;;;;;;;;;0CAOqB,U,EAAY;AAC/B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,qCAAqC,CAAC,UAAD,CAArC;AAF+B,2BAGa,UAHb;AAAA,YAGvB,MAHuB,gBAGvB,MAHuB;AAAA,YAGf,WAHe,gBAGf,WAHe;AAAA,YAGF,UAHE,gBAGF,UAHE;AAK/B,YAAM,GAAG,aAAM,MAAN,8BAAgC,UAAhC,iCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;;;4CAUuB,U,EAAY;AACjC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB;AAAE,UAAA,SAAS,EAAE,IAAI,IAAJ,GAAW,WAAX,GAAyB,KAAzB,CAA+B,CAA/B,EAAkC,CAAlC,CAAb;AAAmD,UAAA,MAAM,EAAE,UAA3D;AAAuE,UAAA,YAAY,EAAE;AAArF,SAAlB,EAAmH,KAAK,OAAxH,EAAiI,UAAjI,CAAb;AACA,QAAA,uCAAuC,CAAC,UAAD,CAAvC;AAFiC,2BAG4C,UAH5C;AAAA,YAGzB,MAHyB,gBAGzB,MAHyB;AAAA,YAGjB,WAHiB,gBAGjB,WAHiB;AAAA,YAGJ,UAHI,gBAGJ,UAHI;AAAA,YAGQ,MAHR,gBAGQ,MAHR;AAAA,YAGgB,SAHhB,gBAGgB,SAHhB;AAAA,YAG2B,YAH3B,gBAG2B,YAH3B;AAKjC,YAAM,GAAG,aAAM,MAAN,8BAAgC,UAAhC,wBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,kCACF,0BAAe,WAAf,CADE;AAEL,YAAA,MAAM,EAAE;AAFH,YAHI;AAOX,UAAA,MAAM,EAAE;AACN,YAAA,SAAS,EAAT;AADM,WAPG;AAUX,UAAA,YAAY,EAAZ;AAVW,SAAN,CAAP;AAYD;AAED;;;;;;;;;;;;;;2CAWsB,U,EAAY;AAChC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB;AAAE,UAAA,MAAM,EAAE,UAAV;AAAsB,UAAA,YAAY,EAAE;AAApC,SAAlB,EAAkE,KAAK,OAAvE,EAAgF,UAAhF,CAAb;AACA,QAAA,sCAAsC,CAAC,UAAD,CAAtC;AAFgC,2BAG8C,UAH9C;AAAA,YAGxB,MAHwB,gBAGxB,MAHwB;AAAA,YAGhB,WAHgB,gBAGhB,WAHgB;AAAA,YAGH,UAHG,gBAGH,UAHG;AAAA,YAGS,KAHT,gBAGS,KAHT;AAAA,YAGgB,GAHhB,gBAGgB,GAHhB;AAAA,YAGqB,MAHrB,gBAGqB,MAHrB;AAAA,YAG6B,YAH7B,gBAG6B,YAH7B;AAKhC,YAAM,GAAG,aAAM,MAAN,8BAAgC,UAAhC,oCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,kCACF,0BAAe,WAAf,CADE;AAEL,YAAA,MAAM,EAAE;AAFH,YAHI;AAOX,UAAA,MAAM,EAAE;AACN,YAAA,KAAK,EAAL,KADM;AAEN,YAAA,GAAG,EAAH;AAFM,WAPG;AAWX,UAAA,YAAY,EAAZ;AAXW,SAAN,CAAP;AAaD;;;;;;AAGH,MAAM,uCAAuC,GAAG,+DAAsB,mCAAtB;AAAgD,IAAA,UAAU,EAAE;AAA5D,KAAhD;;AAEA,MAAM,mCAAmC,GAAG,+DAAsB,mCAAtB;AAAgD,IAAA,UAAU,EAAE;AAA5D,KAA5C;;AAEA,MAAM,wCAAwC,GAAG,+DAAsB,mCAAtB;AAAgD,IAAA,UAAU,EAAE,MAA5D;AAAoE,IAAA,wBAAwB,EAAE;AAA9F,KAAjD;;AAEA,MAAM,qCAAqC,GAAG,+DAAsB,mCAAtB;AAAgD,IAAA,UAAU,EAAE;AAA5D,KAA9C;;AAEA,MAAM,uCAAuC,GAAG,+DAC3C,mCAD2C;AAE9C,IAAA,UAAU,EAAE,MAFkC;AAG9C,IAAA,SAAS,EAAE,WAHmC;AAI9C,IAAA,MAAM,EAAE,0BAAY,CAAC,iBAAD,EAAoB,UAApB,CAAZ,CAJsC;AAK9C,IAAA,YAAY,EAAE;AALgC,KAAhD;;AAQA,MAAM,sCAAsC,GAAG,+DAC1C,mCAD0C;AAE7C,IAAA,UAAU,EAAE,MAFiC;AAG7C,IAAA,KAAK,EAAE,MAHsC;AAI7C,IAAA,GAAG,EAAE,OAJwC;AAK7C,IAAA,MAAM,EAAE,0BAAY,CAAC,iBAAD,EAAoB,UAApB,CAAZ,CALqC;AAM7C,IAAA,YAAY,EAAE;AAN+B,KAA/C;;AASA,EAAA,MAAM,CAAC,OAAP,GAAiB,OAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3NA,MAAM,GAAG,GAAG,uBAAM,iCAAN,CAAZ;AAEA;;;;MAGM,a;AACJ;;;;AAIA,2BAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;uCAMkB,U,EAAY;AAC5B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAF4B,0BAGI,UAHJ;AAAA,YAGpB,MAHoB,eAGpB,MAHoB;AAAA,YAGZ,WAHY,eAGZ,WAHY;AAK5B,YAAM,GAAG,aAAM,MAAN,2BAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;2CAMsB,U,EAAY;AAChC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFgC,2BAGA,UAHA;AAAA,YAGxB,MAHwB,gBAGxB,MAHwB;AAAA,YAGhB,WAHgB,gBAGhB,WAHgB;AAKhC,YAAM,GAAG,aAAM,MAAN,gCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;iDAM4B,U,EAAY;AACtC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFsC,2BAGN,UAHM;AAAA,YAG9B,MAH8B,gBAG9B,MAH8B;AAAA,YAGtB,WAHsB,gBAGtB,WAHsB;AAKtC,YAAM,GAAG,aAAM,MAAN,sCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;4CAMuB,U,EAAY;AACjC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFiC,2BAGD,UAHC;AAAA,YAGzB,MAHyB,gBAGzB,MAHyB;AAAA,YAGjB,WAHiB,gBAGjB,WAHiB;AAKjC,YAAM,GAAG,aAAM,MAAN,iCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;+CAM0B,U,EAAY;AACpC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFoC,2BAGJ,UAHI;AAAA,YAG5B,MAH4B,gBAG5B,MAH4B;AAAA,YAGpB,WAHoB,gBAGpB,WAHoB;AAKpC,YAAM,GAAG,aAAM,MAAN,oCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;gEAM2C,U,EAAY;AACrD,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFqD,2BAGrB,UAHqB;AAAA,YAG7C,MAH6C,gBAG7C,MAH6C;AAAA,YAGrC,WAHqC,gBAGrC,WAHqC;AAKrD,YAAM,GAAG,aAAM,MAAN,uDAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;oEAM+C,U,EAAY;AACzD,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFyD,2BAGzB,UAHyB;AAAA,YAGjD,MAHiD,gBAGjD,MAHiD;AAAA,YAGzC,WAHyC,gBAGzC,WAHyC;AAKzD,YAAM,GAAG,aAAM,MAAN,2DAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;;;;;;AAGH,EAAA,MAAM,CAAC,OAAP,GAAiB,aAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClKA,MAAM,GAAG,GAAG,uBAAM,0BAAN,CAAZ;AAEA;;;;MAGM,O;AACJ;;;;AAIA,qBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;mCAMc,U,EAAY;AACxB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFwB,0BAGQ,UAHR;AAAA,YAGhB,MAHgB,eAGhB,MAHgB;AAAA,YAGR,WAHQ,eAGR,WAHQ;AAKxB,YAAM,GAAG,aAAM,MAAN,sBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;;;;;;AAGH,EAAA,MAAM,CAAC,OAAP,GAAiB,OAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA,MAAM,GAAG,GAAG,uBAAM,uBAAN,CAAZ;AAEA;;;;MAGM,I;AACJ;;;;AAIA,kBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;+BAMU,U,EAAY;AACpB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFoB,0BAGY,UAHZ;AAAA,YAGZ,MAHY,eAGZ,MAHY;AAAA,YAGJ,WAHI,eAGJ,WAHI;AAKpB,YAAM,GAAG,aAAM,MAAN,kBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;qCAQgB,U,EAAY;AAC1B,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;2CAQsB,U,EAAY;AAChC,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;8CAQyB,U,EAAY;AACnC,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;oDAQ+B,U,EAAY;AACzC,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;gDAQ2B,U,EAAY;AACrC,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;+CAQ0B,U,EAAY;AACpC,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;iDAQ4B,U,EAAY;AACtC,eAAO,KAAK,iBAAL,iCAA4B,UAA5B;AAAwC,UAAA,QAAQ,EAAE;AAAlD,WAAP;AACD;AAED;;;;;;;;;;;;wCASmB,U,EAAY;AAC7B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,mCAAmC,CAAC,UAAD,CAAnC;AAF6B,2BAG+B,UAH/B;AAAA,YAGrB,MAHqB,gBAGrB,MAHqB;AAAA,YAGb,WAHa,gBAGb,WAHa;AAAA,YAGA,OAHA,gBAGA,OAHA;AAAA,YAGS,OAHT,gBAGS,OAHT;AAAA,YAGkB,QAHlB,gBAGkB,QAHlB;AAK7B,YAAM,GAAG,aAAM,MAAN,2BAA6B,OAA7B,uBAAiD,QAAjD,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf,CAHE;AAIX,UAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe;AAAE,YAAA,OAAO,EAAP;AAAF,WAAf;AAJK,SAAN,CAAP;AAMD;;;;;;AAGH,MAAM,mCAAmC,GAAG,+DACvC,mCADuC;AAE1C,IAAA,OAAO,EAAE,MAFiC;AAG1C,IAAA,OAAO,EAAE;AAHiC,KAA5C;;AAMA,EAAA,MAAM,CAAC,OAAP,GAAiB,IAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvJA,MAAM,GAAG,GAAG,uBAAM,4BAAN,CAAZ;AAEA;;;;MAGM,Q;AACJ;;;;AAIA,sBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;;;;;0CAUqB,U,EAAY;AAC/B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,qCAAqC,CAAC,UAAD,CAArC;AAF+B,0BAG4E,UAH5E;AAAA,YAGvB,MAHuB,eAGvB,MAHuB;AAAA,YAGf,WAHe,eAGf,WAHe;AAAA,YAGF,UAHE,eAGF,UAHE;AAAA,YAGU,WAHV,eAGU,WAHV;AAAA,YAGuB,uBAHvB,eAGuB,uBAHvB;AAAA,YAGgD,uBAHhD,eAGgD,uBAHhD;AAK/B,YAAM,GAAG,aAAM,MAAN,kCAAoC,UAApC,uBAA2D,WAA3D,0BAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,MAAM,EAAE;AACN,YAAA,uBAAuB,EAAvB,uBADM;AAEN,YAAA,uBAAuB,EAAvB;AAFM,WAHG;AAOX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAPE,SAAN,CAAP;AASD;AAED;;;;;;;;;;;;kCASa,U,EAAY;AACvB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,6BAA6B,CAAC,UAAD,CAA7B;AAFuB,2BAG+C,UAH/C;AAAA,YAGf,MAHe,gBAGf,MAHe;AAAA,YAGP,WAHO,gBAGP,WAHO;AAAA,YAGM,UAHN,gBAGM,UAHN;AAAA,YAGkB,WAHlB,gBAGkB,WAHlB;AAAA,YAG+B,WAH/B,gBAG+B,WAH/B;AAKvB,YAAM,GAAG,aAAM,MAAN,kCAAoC,UAApC,uBAA2D,WAA3D,cAA0E,WAA1E,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;;+CAS0B,U,EAAY;AACpC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,0CAA0C,CAAC,UAAD,CAA1C;AAFoC,2BAGmC,UAHnC;AAAA,YAG5B,MAH4B,gBAG5B,MAH4B;AAAA,YAGpB,WAHoB,gBAGpB,WAHoB;AAAA,YAGP,UAHO,gBAGP,UAHO;AAAA,YAGK,WAHL,gBAGK,WAHL;AAAA,YAGkB,YAHlB,gBAGkB,YAHlB;AAKpC,YAAM,GAAG,aAAM,MAAN,kCAAoC,UAApC,uBAA2D,WAA3D,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,MAAM,EAAE;AACN,YAAA,YAAY,EAAZ;AADM,WAHG;AAMX,UAAA,OAAO,EAAE,0BAAe,WAAf;AANE,SAAN,CAAP;AAQD;;;;;;AAGH,MAAM,qCAAqC,GAAG,+DACzC,mCADyC;AAE5C,IAAA,UAAU,EAAE,MAFgC;AAG5C,IAAA,WAAW,EAAE,MAH+B;AAI5C,IAAA,uBAAuB,EAAE,WAJmB;AAK5C,IAAA,uBAAuB,EAAE;AALmB,KAA9C;;AAQA,MAAM,6BAA6B,GAAG,+DACjC,mCADiC;AAEpC,IAAA,UAAU,EAAE,MAFwB;AAGpC,IAAA,WAAW,EAAE,MAHuB;AAIpC,IAAA,WAAW,EAAE;AAJuB,KAAtC;;AAOA,MAAM,0CAA0C,GAAG,+DAC9C,mCAD8C;AAEjD,IAAA,UAAU,EAAE,MAFqC;AAGjD,IAAA,WAAW,EAAE,MAHoC;AAIjD,IAAA,YAAY,EAAE;AAJmC,KAAnD;;AAOA,EAAA,MAAM,CAAC,OAAP,GAAiB,QAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrHA,MAAM,GAAG,GAAG,uBAAM,2BAAN,CAAZ;AAEA;;;;MAGM,Q;AACJ;;;;AAIA,sBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;uCAMkB,U,EAAY;AAC5B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAF4B,0BAGI,UAHJ;AAAA,YAGpB,MAHoB,eAGpB,MAHoB;AAAA,YAGZ,WAHY,eAGZ,WAHY;AAK5B,YAAM,GAAG,aAAM,MAAN,2BAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;+CAM0B,U,EAAY;AACpC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFoC,2BAGJ,UAHI;AAAA,YAG5B,MAH4B,gBAG5B,MAH4B;AAAA,YAGpB,WAHoB,gBAGpB,WAHoB;AAKpC,YAAM,GAAG,aAAM,MAAN,gCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;;;;;;AAGH,EAAA,MAAM,CAAC,OAAP,GAAiB,QAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDA,MAAM,GAAG,GAAG,uBAAM,0BAAN,CAAZ;AAEA;;;;MAGM,O;AACJ;;;;AAIA,qBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;mCAMc,U,EAAY;AACxB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFwB,0BAGQ,UAHR;AAAA,YAGhB,MAHgB,eAGhB,MAHgB;AAAA,YAGR,WAHQ,eAGR,WAHQ;AAKxB,YAAM,GAAG,aAAM,MAAN,kCAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;iCAOY,U,EAAY;AACtB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,4BAA4B,CAAC,UAAD,CAA5B;AAFsB,2BAGsB,UAHtB;AAAA,YAGd,MAHc,gBAGd,MAHc;AAAA,YAGN,WAHM,gBAGN,WAHM;AAAA,YAGO,UAHP,gBAGO,UAHP;AAKtB,YAAM,GAAG,aAAM,MAAN,2CAA6C,UAA7C,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;oCAOe,U,EAAY;AACzB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,+BAA+B,CAAC,UAAD,CAA/B;AAFyB,2BAGmB,UAHnB;AAAA,YAGjB,MAHiB,gBAGjB,MAHiB;AAAA,YAGT,WAHS,gBAGT,WAHS;AAAA,YAGI,UAHJ,gBAGI,UAHJ;AAKzB,YAAM,GAAG,aAAM,MAAN,2CAA6C,UAA7C,CAAT;AACA,QAAA,GAAG,kBAAW,GAAX,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,QADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;;;;;;AAGH,MAAM,4BAA4B,GAAG,+DAChC,mCADgC;AAEnC,IAAA,UAAU,EAAE;AAFuB,KAArC;;AAKA,MAAM,+BAA+B,GAAG,+DACnC,mCADmC;AAEtC,IAAA,UAAU,EAAE;AAF0B,KAAxC;;AAKA,EAAA,MAAM,CAAC,OAAP,GAAiB,OAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3FA,MAAM,uBAAuB,GAAG,oBAAhC;AACA,MAAM,wBAAwB,GAAG,eAAjC;AAEA,MAAM,GAAG,GAAG,uBAAM,wBAAN,CAAZ;AAEA;;;;MAGM,K;AACJ;;;;AAIA,mBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;qCAKgB,iB,EAAmB;AACjC,eAAO,KAAK,aAAL,CAAmB;AACxB,UAAA,WAAW,EAAE;AACX,YAAA,IAAI,EAAE,iBADK;AAEX,YAAA,UAAU,EAAE,uBAFD;AAGX,YAAA,SAAS,EAAE,KAAK,OAAL,CAAa,QAHb;AAIX,YAAA,aAAa,EAAE,KAAK,OAAL,CAAa,YAJjB;AAKX,YAAA,YAAY,EAAE,KAAK,OAAL,CAAa;AALhB;AADW,SAAnB,CAAP;AASD;AAED;;;;;;;;yCAKoB,Y,EAAc;AAChC,eAAO,KAAK,aAAL,CAAmB;AACxB,UAAA,WAAW,EAAE;AACX,YAAA,aAAa,EAAE,YADJ;AAEX,YAAA,UAAU,EAAE,wBAFD;AAGX,YAAA,SAAS,EAAE,KAAK,OAAL,CAAa,QAHb;AAIX,YAAA,aAAa,EAAE,KAAK,OAAL,CAAa;AAJjB;AADW,SAAnB,CAAP;AAQD;AAED;;;;;;;;;oCAMe,U,EAAY;AACzB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,+BAA+B,CAAC,UAAD,CAA/B;AAFyB,0BAGO,UAHP;AAAA,YAGjB,MAHiB,eAGjB,MAHiB;AAAA,YAGT,WAHS,eAGT,WAHS;AAKzB,YAAM,GAAG,aAAM,MAAN,wBAAT;AACA,QAAA,GAAG,gBAAS,GAAT,0BAA4B,IAAI,CAAC,SAAL,CAAe,WAAf,CAA5B,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,GAAG,EAAH,GADW;AAEX,UAAA,MAAM,EAAE,MAFG;AAGX,UAAA,OAAO,EAAE;AACP,4BAAgB,mCADT;AAEP,YAAA,MAAM,EAAE;AAFD,WAHE;AAOX,UAAA,MAAM,EAAE;AAPG,SAAN,CAAP;AASD;;;;;;AAGH,MAAM,+BAA+B,GAAG,+BAAiB;AACvD,IAAA,MAAM,EAAE,QAD+C;AAEvD,IAAA,WAAW,EAAE,kBAAO,KAAP,CAAa,CACxB,kBAAO,MAAP,CAAc;AACZ,MAAA,SAAS,EAAE,QADC;AAEZ,MAAA,aAAa,EAAE,QAFH;AAGZ,MAAA,UAAU,EAAE,kBAAO,OAAP,CAAe,uBAAf,CAHA;AAIZ,MAAA,IAAI,EAAE,QAJM;AAKZ,MAAA,YAAY,EAAE;AALF,KAAd,CADwB,EAQxB,kBAAO,MAAP,CAAc;AACZ,MAAA,SAAS,EAAE,QADC;AAEZ,MAAA,aAAa,EAAE,QAFH;AAGZ,MAAA,UAAU,EAAE,kBAAO,OAAP,CAAe,wBAAf,CAHA;AAIZ,MAAA,aAAa,EAAE;AAJH,KAAd,CARwB,CAAb;AAF0C,GAAjB,CAAxC;;AAmBA,EAAA,MAAM,CAAC,OAAP,GAAiB,KAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9FA,MAAM,GAAG,GAAG,uBAAM,wBAAN,CAAZ;AAEA;;;;MAGM,K;AACJ;;;;AAIA,mBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;gCAMW,U,EAAY;AACrB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,iDAAyB,UAAzB;AAFqB,0BAGW,UAHX;AAAA,YAGb,MAHa,eAGb,MAHa;AAAA,YAGL,WAHK,eAGL,WAHK;AAKrB,YAAM,GAAG,aAAM,MAAN,mBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;kCAOa,U,EAAY;AACvB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,6BAA6B,CAAC,UAAD,CAA7B;AAFuB,2BAG+B,UAH/B;AAAA,YAGf,MAHe,gBAGf,MAHe;AAAA,YAGP,WAHO,gBAGP,WAHO;AAAA,YAGM,oBAHN,gBAGM,oBAHN;AAKvB,YAAM,GAAG,aAAM,MAAN,mBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AACA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf,CAHE;AAIX,UAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,oBAAf;AAJK,SAAN,CAAP;AAMD;AAED;;;;;;;;;;kCAOa,U,EAAY;AACvB,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,6BAA6B,CAAC,UAAD,CAA7B;AAFuB,2BAGmB,UAHnB;AAAA,YAGf,MAHe,gBAGf,MAHe;AAAA,YAGP,WAHO,gBAGP,WAHO;AAAA,YAGM,QAHN,gBAGM,QAHN;AAKvB,YAAM,GAAG,aAAM,MAAN,4BAA8B,QAA9B,CAAT;AACA,QAAA,GAAG,kBAAW,GAAX,EAAH;AACA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,QADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;;;;;;AAGH,MAAM,6BAA6B,GAAG,+DACjC,mCADiC;AAEpC,IAAA,oBAAoB,EAAE,kBAAO,MAAP,CAAc;AAClC,MAAA,SAAS,EAAE,QADuB;AAElC,MAAA,WAAW,EAAE,SAFqB;AAGlC,MAAA,SAAS,EAAE,0BAAY,CAAC,YAAD,EAAe,UAAf,CAAZ,CAHuB;AAIlC,MAAA,SAAS,EAAE,SAJuB;AAKlC,MAAA,UAAU,EAAE,SALsB;AAMlC,MAAA,QAAQ,EAAE,SANwB;AAOlC,MAAA,YAAY,EAAE,SAPoB;AAQlC,MAAA,WAAW,EAAE,OARqB;AASlC,MAAA,QAAQ,EAAE,kBAAO,QAAP,CAAgB,CAAC,kBAAO,MAAP,CAAc;AACvC,QAAA,WAAW,EAAE,QAD0B;AAEvC,QAAA,cAAc,EAAE,SAFuB;AAGvC,QAAA,WAAW,EAAE,QAH0B;AAIvC,QAAA,iBAAiB,EAAE,QAJoB;AAKvC,QAAA,cAAc,EAAE,QALuB;AAMvC,QAAA,kBAAkB,EAAE,0BAAY,CAAC,WAAD,EAAc,OAAd,EAAuB,MAAvB,EAA+B,KAA/B,EAAsC,UAAtC,EAAkD,SAAlD,CAAZ;AANmB,OAAd,CAAD,CAAhB;AATwB,KAAd;AAFc,KAAtC;;AAsBA,MAAM,6BAA6B,GAAG,+DACjC,mCADiC;AAEpC,IAAA,QAAQ,EAAE;AAF0B,KAAtC;;AAKA,EAAA,MAAM,CAAC,OAAP,GAAiB,KAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1GA,MAAM,GAAG,GAAG,uBAAM,0BAAN,CAAZ;AAEA;;;;MAGM,O;AACJ;;;;AAIA,qBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;;sCAOiB,U,EAAY;AAC3B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,iCAAiC,CAAC,UAAD,CAAjC;AAF2B,0BAGsB,UAHtB;AAAA,YAGnB,MAHmB,eAGnB,MAHmB;AAAA,YAGX,WAHW,eAGX,WAHW;AAAA,YAGE,eAHF,eAGE,eAHF;AAK3B,YAAM,GAAG,aAAM,MAAN,kDAAoD,eAApD,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;8CAOyB,U,EAAY;AACnC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,yCAAyC,CAAC,UAAD,CAAzC;AAFmC,2BAGc,UAHd;AAAA,YAG3B,MAH2B,gBAG3B,MAH2B;AAAA,YAGnB,WAHmB,gBAGnB,WAHmB;AAAA,YAGN,eAHM,gBAGN,eAHM;AAKnC,YAAM,GAAG,aAAM,MAAN,kDAAoD,eAApD,cAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;yCAQoB,U,EAAY;AAC9B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,oCAAoC,CAAC,UAAD,CAApC;AAF8B,2BAG2B,UAH3B;AAAA,YAGtB,MAHsB,gBAGtB,MAHsB;AAAA,YAGd,WAHc,gBAGd,WAHc;AAAA,YAGD,UAHC,gBAGD,UAHC;AAAA,YAGW,WAHX,gBAGW,WAHX;AAK9B,YAAM,GAAG,aAAM,MAAN,4CAA8C,UAA9C,uBAAqE,WAArE,qBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;;uCASkB,U,EAAY;AAC5B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,kCAAkC,CAAC,UAAD,CAAlC;AAF4B,2BAG8C,UAH9C;AAAA,YAGpB,MAHoB,gBAGpB,MAHoB;AAAA,YAGZ,WAHY,gBAGZ,WAHY;AAAA,YAGC,UAHD,gBAGC,UAHD;AAAA,YAGa,WAHb,gBAGa,WAHb;AAAA,YAG0B,eAH1B,gBAG0B,eAH1B;AAK5B,YAAM,GAAG,aAAM,MAAN,4CAA8C,UAA9C,uBAAqE,WAArE,8BAAoG,eAApG,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;;;;;;AAGH,MAAM,iCAAiC,GAAG,+DACrC,mCADqC;AAExC,IAAA,eAAe,EAAE;AAFuB,KAA1C;;AAKA,MAAM,yCAAyC,GAAG,+DAC7C,mCAD6C;AAEhD,IAAA,eAAe,EAAE;AAF+B,KAAlD;;AAKA,MAAM,oCAAoC,GAAG,+DACxC,mCADwC;AAE3C,IAAA,UAAU,EAAE,MAF+B;AAG3C,IAAA,WAAW,EAAE;AAH8B,KAA7C;;AAMA,MAAM,kCAAkC,GAAG,+DACtC,mCADsC;AAEzC,IAAA,UAAU,EAAE,MAF6B;AAGzC,IAAA,WAAW,EAAE,MAH4B;AAIzC,IAAA,eAAe,EAAE;AAJwB,KAA3C;;AAOA,EAAA,MAAM,CAAC,OAAP,GAAiB,OAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjIA,MAAM,GAAG,GAAG,uBAAM,+BAAN,CAAZ;AAEA;;;;MAGM,W;AACJ;;;;AAIA,yBAAa,OAAb,EAAsB;AAAA;;AACpB,WAAK,OAAL,GAAe,OAAf;AACD;AAED;;;;;;;;;;;sCAOiB,U,EAAY;AAC3B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,iCAAiC,CAAC,UAAD,CAAjC;AAF2B,0BAGiB,UAHjB;AAAA,YAGnB,MAHmB,eAGnB,MAHmB;AAAA,YAGX,WAHW,eAGX,WAHW;AAAA,YAGE,UAHF,eAGE,UAHF;AAK3B,YAAM,GAAG,aAAM,MAAN,6BAA+B,UAA/B,mBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;qCAQgB,U,EAAY;AAC1B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,gCAAgC,CAAC,UAAD,CAAhC;AAF0B,2BAGkC,UAHlC;AAAA,YAGlB,MAHkB,gBAGlB,MAHkB;AAAA,YAGV,WAHU,gBAGV,WAHU;AAAA,YAGG,UAHH,gBAGG,UAHH;AAAA,YAGe,cAHf,gBAGe,cAHf;AAK1B,YAAM,GAAG,aAAM,MAAN,6BAA+B,UAA/B,4BAA2D,cAA3D,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;;;;;wCAYmB,U,EAAY;AAC7B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB;AAAE,UAAA,QAAQ,EAAE,KAAZ;AAAmB,UAAA,YAAY,EAAE,CAAjC;AAAoC,UAAA,cAAc,EAAE;AAApD,SAAlB,EAA+E,KAAK,OAApF,EAA6F,UAA7F,CAAb;AACA,QAAA,mCAAmC,CAAC,UAAD,CAAnC;AAF6B,2BAGiF,UAHjF;AAAA,YAGrB,MAHqB,gBAGrB,MAHqB;AAAA,YAGb,WAHa,gBAGb,WAHa;AAAA,YAGA,UAHA,gBAGA,UAHA;AAAA,YAGY,IAHZ,gBAGY,IAHZ;AAAA,YAGkB,QAHlB,gBAGkB,QAHlB;AAAA,YAG4B,YAH5B,gBAG4B,YAH5B;AAAA,YAG0C,cAH1C,gBAG0C,cAH1C;AAAA,YAG0D,kBAH1D,gBAG0D,kBAH1D;AAK7B,YAAM,GAAG,aAAM,MAAN,6BAA+B,UAA/B,mBAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf,CAHE;AAIX,UAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe;AACnB,YAAA,IAAI,EAAJ,IADmB;AAEnB,YAAA,QAAQ,EAAR,QAFmB;AAGnB,YAAA,MAAM,EAAE;AACN,cAAA,UAAU,EAAE,YADN;AAEN,cAAA,QAAQ,EAAE;AAFJ,aAHW;AAOnB,YAAA,kBAAkB,EAAlB;AAPmB,WAAf;AAJK,SAAN,CAAP;AAcD;AAED;;;;;;;;;;;wCAQmB,U,EAAY;AAC7B,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,KAAK,OAAvB,EAAgC,UAAhC,CAAb;AACA,QAAA,mCAAmC,CAAC,UAAD,CAAnC;AAF6B,2BAG+B,UAH/B;AAAA,YAGrB,MAHqB,gBAGrB,MAHqB;AAAA,YAGb,WAHa,gBAGb,WAHa;AAAA,YAGA,UAHA,gBAGA,UAHA;AAAA,YAGY,cAHZ,gBAGY,cAHZ;AAK7B,YAAM,GAAG,aAAM,MAAN,6BAA+B,UAA/B,4BAA2D,cAA3D,CAAT;AACA,QAAA,GAAG,kBAAW,GAAX,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,QADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf;AAHE,SAAN,CAAP;AAKD;AAED;;;;;;;;;;;;;;4CAWuB,U,EAAY;AACjC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB;AAAE,UAAA,QAAQ,EAAE;AAAZ,SAAlB,EAAuC,KAAK,OAA5C,EAAqD,UAArD,CAAb;AACA,QAAA,uCAAuC,CAAC,UAAD,CAAvC;AAFiC,2BAG0D,UAH1D;AAAA,YAGzB,MAHyB,gBAGzB,MAHyB;AAAA,YAGjB,WAHiB,gBAGjB,WAHiB;AAAA,YAGJ,UAHI,gBAGJ,UAHI;AAAA,YAGQ,cAHR,gBAGQ,cAHR;AAAA,YAGwB,WAHxB,gBAGwB,WAHxB;AAAA,YAGqC,MAHrC,gBAGqC,MAHrC;AAAA,YAG6C,QAH7C,gBAG6C,QAH7C;AAKjC,YAAM,GAAG,aAAM,MAAN,6BAA+B,UAA/B,4BAA2D,cAA3D,wBAAuF,WAAvF,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf,CAHE;AAIX,UAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe;AACnB,YAAA,MAAM,EAAE;AACN,cAAA,QAAQ,EAAR,QADM;AAEN,cAAA,UAAU,EAAE;AAFN;AADW,WAAf;AAJK,SAAN,CAAP;AAWD;AAED;;;;;;;;;;;;;;mDAW8B,U,EAAY;AACxC,QAAA,UAAU,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB;AAAE,UAAA,QAAQ,EAAE;AAAZ,SAAlB,EAAuC,KAAK,OAA5C,EAAqD,UAArD,CAAb;AACA,QAAA,8CAA8C,CAAC,UAAD,CAA9C;AAFwC,2BAGmD,UAHnD;AAAA,YAGhC,MAHgC,gBAGhC,MAHgC;AAAA,YAGxB,WAHwB,gBAGxB,WAHwB;AAAA,YAGX,UAHW,gBAGX,UAHW;AAAA,YAGC,cAHD,gBAGC,cAHD;AAAA,YAGiB,WAHjB,gBAGiB,WAHjB;AAAA,YAG8B,MAH9B,gBAG8B,MAH9B;AAAA,YAGsC,QAHtC,gBAGsC,QAHtC;AAKxC,YAAM,GAAG,aAAM,MAAN,6BAA+B,UAA/B,4BAA2D,cAA3D,6BAA4F,WAA5F,CAAT;AACA,QAAA,GAAG,eAAQ,GAAR,EAAH;AAEA,eAAO,uBAAM;AACX,UAAA,MAAM,EAAE,KADG;AAEX,UAAA,GAAG,EAAH,GAFW;AAGX,UAAA,OAAO,EAAE,0BAAe,WAAf,CAHE;AAIX,UAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe;AACnB,YAAA,MAAM,EAAE;AACN,cAAA,QAAQ,EAAR,QADM;AAEN,cAAA,UAAU,EAAE;AAFN;AADW,WAAf;AAJK,SAAN,CAAP;AAWD;;;;;;AAGH,MAAM,iCAAiC,GAAG,+DACrC,mCADqC;AAExC,IAAA,UAAU,EAAE;AAF4B,KAA1C;;AAKA,MAAM,gCAAgC,GAAG,+DACpC,mCADoC;AAEvC,IAAA,UAAU,EAAE,MAF2B;AAGvC,IAAA,cAAc,EAAE;AAHuB,KAAzC;;AAMA,MAAM,mCAAmC,GAAG,+DACvC,mCADuC;AAE1C,IAAA,UAAU,EAAE,MAF8B;AAG1C,IAAA,cAAc,EAAE;AAH0B,KAA5C;;AAMA,MAAM,mCAAmC,GAAG,+DACvC,mCADuC;AAE1C,IAAA,UAAU,EAAE,MAF8B;AAG1C,IAAA,IAAI,EAAE,QAHoC;AAI1C,IAAA,QAAQ,EAAE,QAJgC;AAK1C,IAAA,YAAY,EAAE,QAL4B;AAM1C,IAAA,cAAc,EAAE,QAN0B;AAO1C,IAAA,kBAAkB,EAAE;AAPsB,KAA5C;;AAUA,MAAM,uCAAuC,GAAG,+DAC3C,mCAD2C;AAE9C,IAAA,UAAU,EAAE,MAFkC;AAG9C,IAAA,cAAc,EAAE,MAH8B;AAI9C,IAAA,WAAW,EAAE,MAJiC;AAK9C,IAAA,MAAM,EAAE,QALsC;AAM9C,IAAA,QAAQ,EAAE;AANoC,KAAhD;;AASA,MAAM,8CAA8C,GAAG,+DAClD,mCADkD;AAErD,IAAA,UAAU,EAAE,MAFyC;AAGrD,IAAA,cAAc,EAAE,MAHqC;AAIrD,IAAA,WAAW,EAAE,MAJwC;AAKrD,IAAA,MAAM,EAAE,QAL6C;AAMrD,IAAA,QAAQ,EAAE;AAN2C,KAAvD;;AASA,EAAA,MAAM,CAAC,OAAP,GAAiB,WAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7NA;;;;;;;;;;;;;MAaM,Q;AACJ;;;;AAIA,oBAAa,OAAb,EAAsB;AAAA;;AACpB,QAAM,QAAQ,GAAG;AACf,MAAA,MAAM,EAAE,8BADO;AAEf,MAAA,QAAQ,EAAE,EAFK;AAGf,MAAA,YAAY,EAAE;AAHC,KAAjB;AAMA,SAAK,MAAL,GAAc,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,QAAlB,EAA4B,OAA5B,CAAd;AAEA,SAAK,QAAL,GAAgB,IAAI,oBAAJ,CAAa,KAAK,MAAlB,CAAhB;AACA,SAAK,aAAL,GAAqB,IAAI,yBAAJ,CAAkB,KAAK,MAAvB,CAArB;AACA,SAAK,OAAL,GAAe,IAAI,mBAAJ,CAAY,KAAK,MAAjB,CAAf;AACA,SAAK,OAAL,GAAe,IAAI,mBAAJ,CAAY,KAAK,MAAjB,CAAf;AACA,SAAK,QAAL,GAAgB,IAAI,oBAAJ,CAAa,KAAK,MAAlB,CAAhB;AACA,SAAK,OAAL,GAAe,IAAI,mBAAJ,CAAY,KAAK,MAAjB,CAAf;AACA,SAAK,OAAL,GAAe,IAAI,mBAAJ,CAAY,KAAK,MAAjB,CAAf;AACA,SAAK,KAAL,GAAa,IAAI,iBAAJ,CAAU,KAAK,MAAf,CAAb;AACA,SAAK,IAAL,GAAY,IAAI,gBAAJ,CAAS,KAAK,MAAd,CAAZ;AACA,SAAK,WAAL,GAAmB,IAAI,uBAAJ,CAAgB,KAAK,MAArB,CAAnB;AACA,SAAK,KAAL,GAAa,IAAI,iBAAJ,CAAU,KAAK,MAAf,CAAb;AACD,G;;AAGH,EAAA,MAAM,CAAC,OAAP,GAAiB,QAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDO,MAAM,cAAc,GAAG,SAAjB,cAAiB,CAAC,WAAD;AAAA,WAAkB;AAC9C,MAAA,MAAM,EAAE,kBADsC;AAE9C,MAAA,aAAa,mBAAY,WAAZ;AAFiC,KAAlB;AAAA,GAAvB;;;;AAKA,MAAM,cAAc,GAAG,SAAjB,cAAiB,CAAC,WAAD;AAAA,2CACzB,cAAc,CAAC,WAAD,CADW;AAE5B,sBAAgB;AAFY;AAAA,GAAvB;;;;;;;;;;;;;;;;;;;;;;;;;;ACLP,MAAM,WAAW,GAAG,OAAO,CAAC,aAAD,CAAP,CAAuB,WAA3C;;AACO,MAAM,MAAM,GAAG,WAAW,CAAC;AAChC,IAAA,KAAK,EAAE;AACL,MAAA,IAAI,EAAE,cAAA,KAAK;AAAA,eAAI,2EAA2E,IAA3E,CAAgF,KAAhF,CAAJ;AAAA,OADN;AAEL,MAAA,SAAS,EAAE,mBAAA,KAAK;AAAA,eAAI,+BAA+B,IAA/B,CAAoC,KAApC,CAAJ;AAAA,OAFX;AAGL,MAAA,IAAI,EAAE,cAAA,KAAK;AAAA,eAAI,uDAAuD,IAAvD,CAA4D,KAA5D,CAAJ;AAAA,OAHN;AAIL,MAAA,SAAS,EAAE,mBAAA,KAAK;AAAA,eAAI,oIAAoI,IAApI,CAAyI,KAAzI,CAAJ;AAAA;AAJX;AADyB,GAAD,CAA1B;;AAQA,MAAM,wBAAwB,GAAG;AAAE,IAAA,WAAW,EAAE,QAAf;AAAyB,IAAA,MAAM,EAAE;AAAjC,GAAjC;;AACA,MAAM,wBAAwB,GAAG,MAAM,aAAN,CAAiB,wBAAjB,CAAjC","file":"starling.bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    if (\n      (utils.isBlob(requestData) || utils.isFile(requestData)) &&\n      requestData.type\n    ) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = unescape(encodeURIComponent(config.auth.password)) || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n// eslint-disable-next-line complexity\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true;\n  } // Internet Explorer and Edge do not support colors.\n\n\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  } // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n\n  if (!this.useColors) {\n    return;\n  }\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if (match === '%%') {\n      return;\n    }\n\n    index++;\n\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  var _console;\n\n  // This hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (namespaces) {\n      exports.storage.setItem('debug', namespaces);\n    } else {\n      exports.storage.removeItem('debug');\n    }\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.getItem('debug');\n  } catch (error) {} // Swallow\n  // XXX (@Qix-) should we be logging these?\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\n\nfunction localstorage() {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage;\n  } catch (error) {// Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nmodule.exports = require('./common')(exports);\nvar formatters = module.exports.formatters;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (error) {\n    return '[UnexpectedJSONParseError]: ' + error.message;\n  }\n};\n\n","\"use strict\";\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nfunction setup(env) {\n  createDebug.debug = createDebug;\n  createDebug.default = createDebug;\n  createDebug.coerce = coerce;\n  createDebug.disable = disable;\n  createDebug.enable = enable;\n  createDebug.enabled = enabled;\n  createDebug.humanize = require('ms');\n  Object.keys(env).forEach(function (key) {\n    createDebug[key] = env[key];\n  });\n  /**\n  * Active `debug` instances.\n  */\n\n  createDebug.instances = [];\n  /**\n  * The currently active debug mode names, and names to skip.\n  */\n\n  createDebug.names = [];\n  createDebug.skips = [];\n  /**\n  * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n  *\n  * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n  */\n\n  createDebug.formatters = {};\n  /**\n  * Selects a color for a debug namespace\n  * @param {String} namespace The namespace string for the for the debug instance to be colored\n  * @return {Number|String} An ANSI color code for the given namespace\n  * @api private\n  */\n\n  function selectColor(namespace) {\n    var hash = 0;\n\n    for (var i = 0; i < namespace.length; i++) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n  }\n\n  createDebug.selectColor = selectColor;\n  /**\n  * Create a debugger with the given `namespace`.\n  *\n  * @param {String} namespace\n  * @return {Function}\n  * @api public\n  */\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // Disabled?\n      if (!debug.enabled) {\n        return;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var self = debug; // Set `diff` timestamp\n\n      var curr = Number(new Date());\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr;\n      args[0] = createDebug.coerce(args[0]);\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O');\n      } // Apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return match;\n        }\n\n        index++;\n        var formatter = createDebug.formatters[format];\n\n        if (typeof formatter === 'function') {\n          var val = args[index];\n          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // Apply env-specific formatting (colors, etc.)\n\n      createDebug.formatArgs.call(self, args);\n      var logFn = self.log || createDebug.log;\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = createDebug.enabled(namespace);\n    debug.useColors = createDebug.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy;\n    debug.extend = extend; // Debug.formatArgs = formatArgs;\n    // debug.rawLog = rawLog;\n    // env-specific initialization logic for debug instances\n\n    if (typeof createDebug.init === 'function') {\n      createDebug.init(debug);\n    }\n\n    createDebug.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = createDebug.instances.indexOf(this);\n\n    if (index !== -1) {\n      createDebug.instances.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  function extend(namespace, delimiter) {\n    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n  }\n  /**\n  * Enables a debug mode by namespaces. This can include modes\n  * separated by a colon and wildcards.\n  *\n  * @param {String} namespaces\n  * @api public\n  */\n\n\n  function enable(namespaces) {\n    createDebug.save(namespaces);\n    createDebug.names = [];\n    createDebug.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue;\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < createDebug.instances.length; i++) {\n      var instance = createDebug.instances[i];\n      instance.enabled = createDebug.enabled(instance.namespace);\n    }\n  }\n  /**\n  * Disable debug output.\n  *\n  * @api public\n  */\n\n\n  function disable() {\n    createDebug.enable('');\n  }\n  /**\n  * Returns true if the given mode name is enabled, false otherwise.\n  *\n  * @param {String} name\n  * @return {Boolean}\n  * @api public\n  */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i;\n    var len;\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  * Coerce `val`.\n  *\n  * @param {Mixed} val\n  * @return {Mixed}\n  * @api private\n  */\n\n\n  function coerce(val) {\n    if (val instanceof Error) {\n      return val.stack || val.message;\n    }\n\n    return val;\n  }\n\n  createDebug.enable(createDebug.load());\n  return createDebug;\n}\n\nmodule.exports = setup;\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nvar toString = Object.prototype.toString;\n\nvar kindOf = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n\n/**\r\n * Superstruct ships by default with an unopinionated set of scalar types that\r\n * express all of the data types that are built-in to JavaScript.\r\n */\n\nvar Types = {\n  /**\r\n   * Matches any value other than `undefined`.\r\n   *\r\n   * ```js\r\n   * 'anything'\r\n   * true\r\n   * ```\r\n   */\n  any: function any(value) {\n    return value !== undefined;\n  },\n\n  /**\r\n   * Matches an `arguments` object.\r\n   *\r\n   * ```js\r\n   * arguments\r\n   * ```\r\n   */\n  arguments: function _arguments(value) {\n    return kindOf(value) === 'arguments';\n  },\n\n  /**\r\n   * Matches an `Array`.\r\n   *\r\n   * ```js\r\n   * [1, 2, 3]\r\n   * ```\r\n   */\n  array: function array(value) {\n    return kindOf(value) === 'array';\n  },\n\n  /**\r\n   * Matches a boolean.\r\n   *\r\n   * ```js\r\n   * true\r\n   * false\r\n   * ```\r\n   */\n  boolean: function boolean(value) {\n    return kindOf(value) === 'boolean';\n  },\n\n  /**\r\n   * Matches a Node.js `Buffer`.\r\n   *\r\n   * ```js\r\n   * Buffer.from('string')\r\n   * ```\r\n   */\n  buffer: function buffer(value) {\n    return kindOf(value) === 'buffer';\n  },\n\n  /**\r\n   * Matches a **valid** `Date` object.\r\n   *\r\n   * ```js\r\n   * new Date()\r\n   * ```\r\n   *\r\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\r\n   */\n  date: function date(value) {\n    return kindOf(value) === 'date' && !isNaN(value);\n  },\n\n  /**\r\n   * Matches an error object.\r\n   *\r\n   * ```js\r\n   * new Error()\r\n   * ```\r\n   */\n  error: function error(value) {\n    return kindOf(value) === 'error';\n  },\n\n  /**\r\n   * Matches a `Float32Array` object.\r\n   */\n  float32array: function float32array(value) {\n    return kindOf(value) === 'float32array';\n  },\n\n  /**\r\n   * Matches a `Float64Array` object.\r\n   */\n  float64array: function float64array(value) {\n    return kindOf(value) === 'float64array';\n  },\n\n  /**\r\n   * Matches a function.\r\n   *\r\n   * ```js\r\n   * () => {}\r\n   * function () {}\r\n   * ```\r\n   */\n  function: function _function(value) {\n    return kindOf(value) === 'function';\n  },\n\n  /**\r\n   * Matches a generator function.\r\n   *\r\n   * ```js\r\n   * function* () {}\r\n   * ```\r\n   */\n  generatorfunction: function generatorfunction(value) {\n    return kindOf(value) === 'generatorfunction';\n  },\n\n  /**\r\n   * Matches a `Int16Array` object.\r\n   */\n  int16array: function int16array(value) {\n    return kindOf(value) === 'int16array';\n  },\n\n  /**\r\n   * Matches a `Int32Array` object.\r\n   */\n  int32array: function int32array(value) {\n    return kindOf(value) === 'int32array';\n  },\n\n  /**\r\n   * Matches a `Int8Array` object.\r\n   */\n  int8array: function int8array(value) {\n    return kindOf(value) === 'int8array';\n  },\n\n  /**\r\n   * Matches a `Map` object.\r\n   *\r\n   * ```js\r\n   * new Map()\r\n   * ```\r\n   */\n  map: function map(value) {\n    return kindOf(value) === 'map';\n  },\n\n  /**\r\n   * Matches the `null` literal value.\r\n   *\r\n   * ```js\r\n   * null\r\n   * ```\r\n   */\n  null: function _null(value) {\n    return kindOf(value) === 'null';\n  },\n\n  /**\r\n   * Matches a number.\r\n   *\r\n   * ```js\r\n   * 42\r\n   * ```\r\n   */\n  number: function number(value) {\n    return kindOf(value) === 'number';\n  },\n\n  /**\r\n   * Matches a plain object.\r\n   *\r\n   * ```js\r\n   * { key: 'value' }\r\n   * { something: true }\r\n   * ```\r\n   */\n  object: function object(value) {\n    return kindOf(value) === 'object';\n  },\n\n  /**\r\n   * Matches a `Promise` object.\r\n   *\r\n   * ```js\r\n   * Promise.resolve()\r\n   * ```\r\n   */\n  promise: function promise(value) {\n    return kindOf(value) === 'promise';\n  },\n\n  /**\r\n   * Matches a regular expression object.\r\n   *\r\n   * ```js\r\n   * /a-z/g\r\n   * ```\r\n   */\n  regexp: function regexp(value) {\n    return kindOf(value) === 'regexp';\n  },\n\n  /**\r\n   * Matches a `Set` object.\r\n   *\r\n   * ```js\r\n   * new Set()\r\n   * ```\r\n   */\n  set: function set(value) {\n    return kindOf(value) === 'set';\n  },\n\n  /**\r\n   * Matches a string.\r\n   *\r\n   * ```js\r\n   * 'text'\r\n   * ```\r\n   */\n  string: function string(value) {\n    return kindOf(value) === 'string';\n  },\n\n  /**\r\n   * Matches a `Symbol`.\r\n   *\r\n   * ```js\r\n   * Symbol()\r\n   * ```\r\n   */\n  symbol: function symbol(value) {\n    return kindOf(value) === 'symbol';\n  },\n\n  /**\r\n   * Matches a `Uint16Array` object.\r\n   */\n  uint16array: function uint16array(value) {\n    return kindOf(value) === 'uint16array';\n  },\n\n  /**\r\n   * Matches a `Uint32Array` object.\r\n   */\n  uint32array: function uint32array(value) {\n    return kindOf(value) === 'uint32array';\n  },\n\n  /**\r\n   * Matches a `Uint8Array` object.\r\n   */\n  uint8array: function uint8array(value) {\n    return kindOf(value) === 'uint8array';\n  },\n\n  /**\r\n   * Matches a `Uint8ClampedArray` object.\r\n   */\n  uint8clampedarray: function uint8clampedarray(value) {\n    return kindOf(value) === 'uint8clampedarray';\n  },\n\n  /**\r\n   * Matches the `undefined` literal value.\r\n   *\r\n   * ```js\r\n   * undefined\r\n   * ```\r\n   */\n  undefined: function undefined$1(value) {\n    return kindOf(value) === 'undefined';\n  },\n\n  /**\r\n   * Matches a `WeakMap` object.\r\n   *\r\n   * ```js\r\n   * new WeakMap()\r\n   * ```\r\n   */\n  weakmap: function weakmap(value) {\n    return kindOf(value) === 'weakmap';\n  },\n\n  /**\r\n   * Matches a `WeakSet` object.\r\n   *\r\n   * ```js\r\n   * new WeakSet()\r\n   * ```\r\n   */\n  weakset: function weakset(value) {\n    return kindOf(value) === 'weakset';\n  }\n};\n\nvar isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\n/**\r\n * `StructError` objects are thrown (or returned) by Superstruct when its\r\n * validation fails. The error represents the first error encountered during\r\n * validation. But they also have an `error.failures` property that holds\r\n * information for all of the failures encountered.\r\n */\n\nvar StructError = /*#__PURE__*/function (_TypeError) {\n  _inheritsLoose(StructError, _TypeError);\n\n  function StructError(failures) {\n    var _this;\n\n    invariant(failures.length > 0, \"StructError requires being passed a failure, but received: \" + failures);\n    var first = failures[0];\n\n    var path = first.path,\n        value = first.value,\n        type = first.type,\n        branch = first.branch,\n        rest = _objectWithoutPropertiesLoose(first, [\"path\", \"value\", \"type\", \"branch\"]);\n\n    var message = \"Expected a value of type `\" + type + \"`\" + (path.length ? \" for `\" + path.join('.') + \"`\" : '') + \" but received `\" + JSON.stringify(value) + \"`.\";\n    _this = _TypeError.call(this, message) || this;\n    _this.type = type;\n    _this.value = value;\n    Object.assign(_assertThisInitialized(_this), rest);\n    _this.path = path;\n    _this.branch = branch;\n    _this.failures = failures;\n    _this.stack = new Error().stack;\n    _this.__proto__ = StructError.prototype;\n    return _this;\n  }\n\n  return StructError;\n}( /*#__PURE__*/_wrapNativeSuper(TypeError));\n\n/**\r\n * A symbol to set on `Struct` objects to test them against later.\r\n */\nvar STRUCT = Symbol('STRUCT');\n/**\r\n * Check if a value is a `Struct` object.\r\n */\n\nvar isStruct = function isStruct(value) {\n  return typeof value === 'function' && value[STRUCT];\n};\n/**\r\n * This abstract `Struct` factory creates a generic struct that validates values\r\n * against a `Validator` function.\r\n */\n\nvar createStruct = function createStruct(props) {\n  var struct = props.struct;\n  var Error = struct.Error;\n\n  var Struct = function Struct(value) {\n    return Struct.assert(value);\n  }; // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n\n\n  Object.defineProperty(Struct, STRUCT, {\n    value: true\n  });\n  Struct.kind = props.kind;\n  Struct.type = props.type;\n\n  Struct.default = function () {\n    return typeof props.defaults === 'function' ? props.defaults() : props.defaults;\n  };\n\n  Struct.test = function (value) {\n    var _Struct$check = Struct.check(value, [value], []),\n        failures = _Struct$check[0];\n\n    return !failures;\n  };\n\n  Struct.assert = function (value) {\n    var _Struct$check2 = Struct.check(value, [value], []),\n        failures = _Struct$check2[0],\n        result = _Struct$check2[1];\n\n    if (failures) {\n      throw new Error(failures);\n    } else {\n      return result;\n    }\n  };\n\n  Struct.validate = function (value) {\n    var _Struct$check3 = Struct.check(value, [value], []),\n        failures = _Struct$check3[0],\n        result = _Struct$check3[1];\n\n    if (failures) {\n      return [new Error(failures)];\n    } else {\n      return [undefined, result];\n    }\n  };\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var failures = [Struct.fail({\n      value: value,\n      branch: branch,\n      path: path\n    })];\n    return [failures];\n  };\n\n  Struct.fail = function (obj) {\n    return _objectSpread2(_objectSpread2({}, obj), {}, {\n      type: 'type' in obj ? obj.type : Struct.type\n    });\n  };\n\n  return Struct;\n};\n\nvar createArray = function createArray(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 1, \"Array structs must be defined as an array with one element, but you passed: \" + schema);\n  var Element = struct(schema[0], undefined);\n  var Struct = createStruct({\n    kind: 'array',\n    type: Element.type + \"[]\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = [];\n    var failures = [];\n\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n\n      var _Element$check = Element.check(v, branch.concat(v), path.concat(i)),\n          efs = _Element$check[0],\n          er = _Element$check[1];\n\n      if (efs) {\n        failures.push.apply(failures, efs);\n        continue;\n      }\n\n      result[i] = er;\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createDynamic = function createDynamic(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Dynamic structs must be defined as a function, but you passed: \" + schema);\n  var Dynamic = createStruct({\n    kind: 'dynamic',\n    type: \"dynamic<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Dynamic.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Dynamic.default();\n    }\n\n    var Struct = schema(value, branch, path);\n    return Struct.check(value, branch, path);\n  };\n\n  return Dynamic;\n};\n\nvar createEnum = function createEnum(schema, defaults, struct) {\n  invariant(Array.isArray(schema), \"Enum structs must be defined as an array, but you passed: \" + schema);\n\n  var validator = function validator(value) {\n    return schema.includes(value);\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'enum';\n  Struct.type = schema.map(function (s) {\n    return typeof s === 'string' ? \"\\\"\" + s + \"\\\"\" : \"\" + s;\n  }).join(' | ');\n  return Struct;\n};\n\nvar createFunction = function createFunction(schema, defaults, struct) {\n  var Struct = createStruct({\n    kind: 'function',\n    type: \"function<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var result = schema(value, branch, path);\n\n    if (result === true) {\n      return [undefined, value];\n    }\n\n    var failures = [];\n\n    if (result === false) {\n      failures.push(Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      }));\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (var _iterator = _createForOfIteratorHelperLoose(result), _step; !(_step = _iterator()).done;) {\n        var r = _step.value;\n        failures.push(Struct.fail(_objectSpread2({\n          value: value,\n          branch: branch,\n          path: path\n        }, r)));\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail(_objectSpread2({\n        value: value,\n        branch: branch,\n        path: path\n      }, result)));\n    } else {\n      invariant(false, \"Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: \" + result);\n    }\n\n    return [failures];\n  };\n\n  return Struct;\n};\n\nvar createInstance = function createInstance(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Instance structs must be defined as a function, but you passed: \" + schema);\n\n  var validator = function validator(value) {\n    return value instanceof schema;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'instance';\n  Struct.type = \"instance<\" + schema.name + \">\";\n  return Struct;\n};\n\nvar createInterface = function createInterface(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Interface structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'interface',\n    type: \"interface<{\" + Object.keys(schema).join() + \"}>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var failures = [];\n\n    for (var k in Props) {\n      var Prop = Props[k];\n      var v = value[k];\n\n      var _Prop$check = Prop.check(v, branch.concat(v), path.concat(k)),\n          pfs = _Prop$check[0];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value];\n  };\n\n  return Struct;\n};\n\nvar createIntersection = function createIntersection(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length !== 0, \"Intersection structs must be defined as a non-empty array, but you passed: \" + schema);\n  var Structs = schema.map(function (sch) {\n    return struct(sch);\n  });\n  var type = Structs.map(function (s) {\n    return s.type;\n  }).join(' & ');\n  var Struct = createStruct({\n    kind: 'intersection',\n    type: type,\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var result = value;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(Structs), _step; !(_step = _iterator()).done;) {\n      var _struct = _step.value;\n\n      var _struct$check = _struct.check(value, branch, path),\n          fs = _struct$check[0],\n          v = _struct$check[1];\n\n      if (fs) {\n        return [[Struct.fail({\n          value: value,\n          branch: branch,\n          path: path\n        })]];\n      } else {\n        result = v;\n      }\n    }\n\n    return [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createLazy = function createLazy(schema, defaults, struct) {\n  invariant(typeof schema === 'function', \"Lazy structs must be defined as a function, but you passed: \" + schema);\n  var Lazy = createStruct({\n    kind: 'lazy',\n    type: \"lazy<\\u2026>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Lazy.check = function () {\n    Object.assign(Lazy, schema());\n    return Lazy.check.apply(Lazy, arguments);\n  };\n\n  return Lazy;\n};\n\nvar createSize = function createSize(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 2 && schema.every(function (n) {\n    return typeof n === 'number';\n  }), \"Size structs must be defined as an array with two number elements, but you passed: \" + schema);\n  var min = schema[0],\n      max = schema[1];\n\n  var validator = function validator(value) {\n    return value != null && typeof value.length === 'number' && value.length >= min && value.length <= max;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'size';\n  Struct.type = \"size<\" + min + \",\" + max + \">\";\n  return Struct;\n};\n\nvar createLiteral = function createLiteral(schema, defaults, struct) {\n  var validator = function validator(value) {\n    return value === schema;\n  };\n\n  var Struct = struct(validator, defaults);\n  Struct.kind = 'literal';\n  Struct.type = typeof schema === 'string' ? \"\\\"\" + schema + \"\\\"\" : \"\" + schema;\n  return Struct;\n};\n\nvar createObject = function createObject(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Object structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'object',\n    type: \"{\" + Object.keys(schema).join() + \"}\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n    var keys = new Set(Object.keys(Props).concat(Object.keys(value)));\n\n    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {\n      var k = _step.value;\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      if (!(k in Props)) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: value\n        }));\n        continue;\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createPartial = function createPartial(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Partial structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined']);\n  }\n\n  var Struct = createStruct({\n    kind: 'object',\n    type: \"{\" + Object.keys(schema).join() + \"}\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var _iterator = _createForOfIteratorHelperLoose(value), _step; !(_step = _iterator()).done;) {\n      var k = _step.value;\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      if (!(k in Props)) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: value\n        }));\n        continue;\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createPick = function createPick(schema, defaults, struct) {\n  invariant(typeof schema === 'object', \"Pick structs must be defined as an object, but you passed: \" + schema);\n  var Props = {};\n\n  for (var key in schema) {\n    Props[key] = struct(schema[key]);\n  }\n\n  var Struct = createStruct({\n    kind: 'pick',\n    type: \"pick<{\" + Object.keys(schema).join() + \"}>\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    var d = Struct.default();\n\n    if (value === undefined) {\n      value = d;\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var k in Props) {\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n      var Prop = Props[k];\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k];\n      }\n\n      var _Prop$check = Prop.check(v, b, p),\n          pfs = _Prop$check[0],\n          pr = _Prop$check[1];\n\n      if (pfs) {\n        failures.push.apply(failures, pfs);\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr;\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createRecord = function createRecord(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length === 2, \"Record structs must be defined as an array with two elements, but you passed: \" + schema);\n  var Key = struct(schema[0]);\n  var Value = struct(schema[1]);\n  var Struct = createStruct({\n    kind: 'record',\n    type: \"record<\" + Key.type + \",\" + Value.type + \">\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    var defs = Struct.default();\n    value = defs ? _objectSpread2(_objectSpread2({}, defs), value) : value;\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = {};\n    var failures = [];\n\n    for (var k in value) {\n      var v = value[k];\n      var p = path.concat(k);\n      var b = branch.concat(v);\n\n      var _Key$check = Key.check(k, b, p),\n          kfs = _Key$check[0],\n          kr = _Key$check[1];\n\n      if (kfs) {\n        failures.push.apply(failures, kfs);\n      } else {\n        var _Value$check = Value.check(v, b, p),\n            vfs = _Value$check[0],\n            vr = _Value$check[1];\n\n        if (vfs) {\n          failures.push.apply(failures, vfs);\n        } else {\n          result[kr] = vr;\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createScalar = function createScalar(schema, defaults, struct) {\n  invariant(typeof schema === 'string', \"Scalar structs must be defined as a string, but you passed: \" + schema);\n  var Types = struct.Types;\n  invariant(schema in Types, \"No struct validator function found for type \\\"\" + schema + \"\\\".\");\n  var Struct = struct(Types[schema], defaults);\n  Struct.kind = 'scalar';\n  Struct.type = schema;\n  return Struct;\n};\n\nvar createShorthand = function createShorthand(schema, defaults, struct) {\n  if (isStruct(schema)) {\n    return schema;\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      var _schema = schema,\n          first = _schema[0];\n      return struct.array([first], defaults);\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults);\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults);\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults);\n  }\n\n  if (typeof schema === 'string') {\n    var optional = false;\n    var Struct;\n\n    if (schema.endsWith('?')) {\n      optional = true;\n      schema = schema.slice(0, -1);\n    }\n\n    if (schema.includes('|')) {\n      var scalars = schema.split(/\\s*\\|\\s*/g);\n      Struct = struct.union(scalars, defaults);\n    } else if (schema.includes('&')) {\n      var _scalars = schema.split(/\\s*&\\s*/g);\n\n      Struct = struct.intersection(_scalars, defaults);\n    } else {\n      Struct = struct.scalar(schema, defaults);\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined);\n    }\n\n    return Struct;\n  }\n\n  throw new Error(\"A schema definition must be an object, array, string or function, but you passed: \" + schema);\n};\n\nvar createTuple = function createTuple(schema, defaults, struct) {\n  invariant(Array.isArray(schema), \"Tuple structs must be defined as an array, but you passed: \" + schema);\n  var Elements = schema.map(function (s) {\n    return struct(s);\n  });\n  var Struct = createStruct({\n    kind: 'tuple',\n    type: \"[\" + Elements.map(function (S) {\n      return S.type;\n    }).join() + \"]\",\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({\n        value: value,\n        branch: branch,\n        path: path\n      })]];\n    }\n\n    var result = [];\n    var failures = [];\n    var length = Math.max(value.length, Elements.length);\n\n    for (var i = 0; i < length; i++) {\n      var Element = Elements[i];\n      var v = value[i];\n      var p = path.concat(i);\n      var b = branch.concat(v);\n\n      if (!Element) {\n        failures.push(Struct.fail({\n          type: undefined,\n          value: v,\n          path: p,\n          branch: b\n        }));\n      } else {\n        var _Element$check = Element.check(v, b, p),\n            efs = _Element$check[0],\n            er = _Element$check[1];\n\n        if (efs) {\n          failures.push.apply(failures, efs);\n        } else {\n          result[i] = er;\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result];\n  };\n\n  return Struct;\n};\n\nvar createUnion = function createUnion(schema, defaults, struct) {\n  invariant(Array.isArray(schema) && schema.length !== 0, \"Union structs must be defined as a non-empty array, but you passed: \" + schema);\n  var Structs = schema.map(function (sch) {\n    return struct(sch);\n  });\n  var type = Structs.map(function (s) {\n    return s.type;\n  }).join(' | ');\n  var Struct = createStruct({\n    kind: 'union',\n    type: type,\n    defaults: defaults,\n    struct: struct\n  });\n\n  Struct.check = function (value, branch, path) {\n    if (value === void 0) {\n      value = Struct.default();\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(Structs), _step; !(_step = _iterator()).done;) {\n      var _struct = _step.value;\n\n      var _struct$check = _struct.check(value, branch, path),\n          fs = _struct$check[0],\n          v = _struct$check[1];\n\n      if (!fs) {\n        return [undefined, v];\n      }\n    }\n\n    return [[Struct.fail({\n      value: value,\n      branch: branch,\n      path: path\n    })]];\n  };\n\n  return Struct;\n};\n\n/**\r\n * Create a struct singleton with settings that include your own domain-specific\r\n * data `types`, and an optional custom `Error` class.\r\n */\n\nvar superstruct = function superstruct(settings) {\n  if (settings === void 0) {\n    settings = {};\n  }\n\n  var struct = function struct(schema, defaults) {\n    return createShorthand(schema, defaults, struct);\n  };\n\n  struct.array = function (schema, defaults) {\n    return createArray(schema, defaults, struct);\n  };\n\n  struct.dynamic = function (schema, defaults) {\n    return createDynamic(schema, defaults, struct);\n  };\n\n  struct.enum = function (schema, defaults) {\n    return createEnum(schema, defaults, struct);\n  };\n\n  struct.function = function (schema, defaults) {\n    return createFunction(schema, defaults, struct);\n  };\n\n  struct.instance = function (schema, defaults) {\n    return createInstance(schema, defaults, struct);\n  };\n\n  struct.interface = function (schema, defaults) {\n    return createInterface(schema, defaults, struct);\n  };\n\n  struct.intersection = function (schema, defaults) {\n    return createIntersection(schema, defaults, struct);\n  };\n\n  struct.lazy = function (schema, defaults) {\n    return createLazy(schema, defaults, struct);\n  };\n\n  struct.literal = function (schema, defaults) {\n    return createLiteral(schema, defaults, struct);\n  };\n\n  struct.object = function (schema, defaults) {\n    return createObject(schema, defaults, struct);\n  };\n\n  struct.optional = function (schema, defaults) {\n    return createUnion([schema, 'undefined'], defaults, struct);\n  };\n\n  struct.partial = function (schema, defaults) {\n    return createPartial(schema, defaults, struct);\n  };\n\n  struct.pick = function (schema, defaults) {\n    return createPick(schema, defaults, struct);\n  };\n\n  struct.record = function (schema, defaults) {\n    return createRecord(schema, defaults, struct);\n  };\n\n  struct.scalar = function (schema, defaults) {\n    return createScalar(schema, defaults, struct);\n  };\n\n  struct.size = function (schema, defaults) {\n    return createSize(schema, defaults, struct);\n  };\n\n  struct.tuple = function (schema, defaults) {\n    return createTuple(schema, defaults, struct);\n  };\n\n  struct.union = function (schema, defaults) {\n    return createUnion(schema, defaults, struct);\n  };\n\n  struct.Error = settings.error || StructError;\n  struct.Types = _objectSpread2(_objectSpread2({}, Types), settings.types);\n  return struct;\n};\n\n/**\r\n * The singleton instance of Superstruct that is exported by default, configured\r\n * with types for all of the JavaScript built-in data types.\r\n *\r\n * You can use it if you don't need any custom types. However, if you do want to\r\n * define custom types, use the [[superstruct]] factory to configure your own\r\n * [[Superstruct]] instance.\r\n */\n\nvar struct = superstruct();\n\nexports.StructError = StructError;\nexports.Types = Types;\nexports.isStruct = isStruct;\nexports.struct = struct;\nexports.superstruct = superstruct;\n//# sourceMappingURL=index.cjs.map\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion, minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:account-service')\n\n/**\n * Service to interact with a customer's account\n */\nclass Account {\n  /**\n   * Creates an instance of the account client\n   * @param {Object} options - application config\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get an account holder's bank accounts\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccounts (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get an account's bank identifiers\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @return {Promise} - the http request promise\n   */\n  getAccountIdentifiers (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getAccountIdentifiersParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts/${accountUid}/identifiers`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get an account's balance\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @return {Promise} - the http request promise\n   */\n  getAccountBalance (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getAccountBalanceParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts/${accountUid}/balance`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get whether there are available funds for a requested amount\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {number} parameters.targetAmountInMinorUnits - the target amount in minor units\n   * @return {Promise} - the http request promise\n   */\n  getConfirmationOfFunds (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getConfirmationOfFundsParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, targetAmountInMinorUnits } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts/${accountUid}/confirmation-of-funds`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken),\n      params: {\n        targetAmountInMinorUnits\n      }\n    })\n  }\n\n  /**\n   * Get list of statement periods which are available for an account\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @return {Promise} - the http request promise\n   */\n  getStatementPeriods (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getStatementPeriodsParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts/${accountUid}/statement/available-periods`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Download a statement for a given statement period\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string=} parameters.yearMonth - the statement period's year month (yyyy-MM)\n   * @param {string=} parameters.format - one of 'application/pdf' or 'text/csv'\n   * @param {string=} parameters.responseType - the axios responseType for the request\n   * @return {Promise} - the http request promise\n   */\n  getStatementForPeriod (parameters) {\n    parameters = Object.assign({}, { yearMonth: new Date().toISOString().slice(0, 7), format: 'text/csv', responseType: 'stream' }, this.options, parameters)\n    getStatementForPeriodParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, format, yearMonth, responseType } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts/${accountUid}/statement/download`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: {\n        ...defaultHeaders(accessToken),\n        Accept: format\n      },\n      params: {\n        yearMonth\n      },\n      responseType\n    })\n  }\n\n  /**\n   * Download a statement for a given date range\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.start - the beginning of the statement date range (yyyy-MM-dd)\n   * @param {string=} parameters.end - the end of the statement date range (yyyy-MM-dd)\n   * @param {string=} parameters.format - one of 'application/pdf' or 'text/csv'\n   * @param {string=} parameters.responseType - the axios responseType for the request\n   * @return {Promise} - the http request promise\n   */\n  getStatementForRange (parameters) {\n    parameters = Object.assign({}, { format: 'text/csv', responseType: 'stream' }, this.options, parameters)\n    getStatementForRangeParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, start, end, format, responseType } = parameters\n\n    const url = `${apiUrl}/api/v2/accounts/${accountUid}/statement/downloadForDateRange`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: {\n        ...defaultHeaders(accessToken),\n        Accept: format\n      },\n      params: {\n        start,\n        end\n      },\n      responseType\n    })\n  }\n}\n\nconst getAccountIdentifiersParameterValidator = struct.interface({ ...minAPIParameterDefintion, accountUid: 'uuid' })\n\nconst getAccountBalanceParameterValidator = struct.interface({ ...minAPIParameterDefintion, accountUid: 'uuid' })\n\nconst getConfirmationOfFundsParameterValidator = struct.interface({ ...minAPIParameterDefintion, accountUid: 'uuid', targetAmountInMinorUnits: 'number' })\n\nconst getStatementPeriodsParameterValidator = struct.interface({ ...minAPIParameterDefintion, accountUid: 'uuid' })\n\nconst getStatementForPeriodParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  yearMonth: 'yearMonth',\n  format: struct.enum(['application/pdf', 'text/csv']),\n  responseType: 'string'\n})\n\nconst getStatementForRangeParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  start: 'date',\n  end: 'date?',\n  format: struct.enum(['application/pdf', 'text/csv']),\n  responseType: 'string'\n})\n\nmodule.exports = Account\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:account-holder-service')\n\n/**\n * Service to interact with an account holder\n */\nclass AccountHolder {\n  /**\n   * Creates an instance of the account holder client\n   * @param {Object} options - application config\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get basic information about the account holder\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolder (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get the name of the account holder\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolderName (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder/name`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get an individual account holder's details\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolderIndividual (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder/individual`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a joint account holder's details\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolderJoint (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder/joint`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a business account holder's details\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolderBusiness (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder/business`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a business account holder's registered address\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolderBusinessRegisteredAddress (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder/business/registered-address`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a business account holder's correspondence address\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getAccountHolderBusinessCorrespondenceAddress (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/account-holder/business/correspondence-address`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nmodule.exports = AccountHolder\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:address-service')\n\n/**\n * Service to interact with a customer address\n */\nclass Address {\n  /**\n   * Creates an instance of the address client\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Retrieves a customer's address\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @return {Promise} - the http request promise\n   */\n  getAddresses (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/addresses`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nmodule.exports = Address\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders, payloadHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion, minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:card-service')\n\n/**\n * Service to interact with a customer card\n */\nclass Card {\n  /**\n   * Creates an instance of the client's card\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get all the cards for an account holder\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  getCards (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/cards`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Update card lock\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether the card should be locked. Set to false to lock, true to unlock.\n   * @return {Promise} - the http request promise\n   */\n  updateCardLock (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'enabled' })\n  }\n\n  /**\n   * Update ATM withdrawal control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether ATM withdrawals should be allowed. Set to false to block, true to allow.\n   * @return {Promise} - the http request promise\n   */\n  updateCardATMControl (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'atm-enabled' })\n  }\n\n  /**\n   * Update online payments control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether online payments should be allowed. Set to false to block, true to allow.\n   * @return {Promise} - the http request promise\n   */\n  updateCardOnlineControl (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'online-enabled' })\n  }\n\n  /**\n   * Update mobile wallet payments control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether mobile wallet payments should be allowed. Set to false to block, true to allow.\n   * @return {Promise} - the http request promise\n   */\n  updateCardMobileWalletControl (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'mobile-wallet-enabled' })\n  }\n\n  /**\n   * Update gambling payments control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether gambling payments should be allowed. Set to false to block, true to allow.\n   * @return {Promise} - the http request promise\n   */\n  updateCardGamblingControl (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'gambling-enabled' })\n  }\n\n  /**\n   * Update card present payments (contactless and chip and pin) control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether card present payments (contactless and chip and pin) should be allowed. Set to false to block, true to allow.\n   * @return {Promise} - the http request promise\n   */\n  updateCardPresentControl (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'pos-enabled' })\n  }\n\n  /**\n   * Update magstripe payments control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether magstripe payments should be allowed. Set to false to block, true to allow.\n   * @return {Promise} - the http request promise\n   */\n  updateCardMagstripeControl (parameters) {\n    return this.updateCardControl({ ...parameters, endpoint: 'mag-stripe-enabled' })\n  }\n\n  /**\n   * Update a card control\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.cardUid - the card uid\n   * @param {boolean} parameters.enabled - Whether the control should be should be locked. Set to false to lock, true to unlock.\n   * @param {string} parameters.endpoint - the last segment of the endpoint name\n   * @return {Promise} - the http request promise\n   */\n  updateCardControl (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    updateCardControlParameterValidator(parameters)\n    const { apiUrl, accessToken, cardUid, enabled, endpoint } = parameters\n\n    const url = `${apiUrl}/api/v2/cards/${cardUid}/controls/${endpoint}`\n    log(`PUT ${url}`)\n\n    return axios({\n      method: 'PUT',\n      url,\n      headers: payloadHeaders(accessToken),\n      data: JSON.stringify({ enabled })\n    })\n  }\n}\n\nconst updateCardControlParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  cardUid: 'uuid',\n  enabled: 'boolean'\n})\n\nmodule.exports = Card\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion } from '../utils/validator'\n\nconst log = debug('starling:feed-item-service')\n\n/**\n * Service to interact with a customer's feed items\n */\nclass FeedItem {\n  /**\n   * Create a new feed item service\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get feed items created between two timestamps\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.categoryUid - the category uid\n   * @param {string} parameters.minTransactionTimestamp - timestamp e.g. '2019-10-25T12:34:56.789Z'\n   * @param {string} parameters.maxTransactionTimestamp - timestamp e.g. '2019-10-26T12:34:56.789Z'\n   * @return {Promise} - the http request promise\n   */\n  getFeedItemsBetween (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getFeedItemsBetweenParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, categoryUid, minTransactionTimestamp, maxTransactionTimestamp } = parameters\n\n    const url = `${apiUrl}/api/v2/feed/account/${accountUid}/category/${categoryUid}/transactions-between`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      params: {\n        minTransactionTimestamp,\n        maxTransactionTimestamp\n      },\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a feed item\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.categoryUid - the category uid\n   * @param {string} parameters.feedItemUid - the feed item uid\n   * @return {Promise} - the http request promise\n   */\n  getFeedItem (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getFeedItemParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, categoryUid, feedItemUid } = parameters\n\n    const url = `${apiUrl}/api/v2/feed/account/${accountUid}/category/${categoryUid}/${feedItemUid}`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get feed items created or updated since a given timestamp\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.categoryUid - the category uid\n   * @param {string} parameters.changesSince - timestamp e.g. '2019-10-25T12:34:56.789Z'\n   * @return {Promise} - the http request promise\n   */\n  getFeedItemsChangedSince (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getFeedItemsChangedSinceParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, categoryUid, changesSince } = parameters\n\n    const url = `${apiUrl}/api/v2/feed/account/${accountUid}/category/${categoryUid}`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      params: {\n        changesSince\n      },\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nconst getFeedItemsBetweenParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  categoryUid: 'uuid',\n  minTransactionTimestamp: 'timestamp',\n  maxTransactionTimestamp: 'timestamp'\n})\n\nconst getFeedItemParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  categoryUid: 'uuid',\n  feedItemUid: 'uuid'\n})\n\nconst getFeedItemsChangedSinceParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  categoryUid: 'uuid',\n  changesSince: 'timestamp'\n})\n\nmodule.exports = FeedItem\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:identity-service')\n\n/**\n * Service to interact with the API User identities endpoints\n */\nclass Identity {\n  /**\n   * Creates an instance of the identity client\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get the current token identity\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @return {Promise} - the http request promise\n   */\n  getTokenIdentity (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/identity/token`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get the authorising individual's identity\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @return {Promise} - the http request promise\n   */\n  getAuthorisingIndividual (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/identity/individual`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nmodule.exports = Identity\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion, minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:mandate-service')\n\n/**\n * Service to interact with a customer's mandates\n */\nclass Mandate {\n  /**\n   * Create a new mandate service\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Gets a list of the customer's current direct debit mandates\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @return {Promise} - the http request promise\n   */\n  listMandates (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/direct-debit/mandates`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Gets a specific direct debit mandate\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.mandateUid - unique identifier of the mandate\n   * @return {Promise} - the http request promise\n   */\n  getMandate (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getMandateParameterValidator(parameters)\n    const { apiUrl, accessToken, mandateUid } = parameters\n\n    const url = `${apiUrl}/api/v2/direct-debit/mandates/${mandateUid}`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Deletes specific direct debit mandate\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @param {string} parameters.mandateUid - the unique mandate ID\n   * @return {Promise} - the http request promise\n   */\n  deleteMandate (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    deleteMandateParameterValidator(parameters)\n    const { apiUrl, accessToken, mandateUid } = parameters\n\n    const url = `${apiUrl}/api/v2/direct-debit/mandates/${mandateUid}`\n    log(`DELETE ${url}`)\n\n    return axios({\n      method: 'DELETE',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nconst getMandateParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  mandateUid: 'uuid'\n})\n\nconst deleteMandateParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  mandateUid: 'uuid'\n})\n\nmodule.exports = Mandate\n","import axios from 'axios'\nimport debug from 'debug'\nimport { struct } from '../utils/validator'\n\nconst ACCESS_TOKEN_GRANT_TYPE = 'authorization_code'\nconst REFRESH_TOKEN_GRANT_TYPE = 'refresh_token'\n\nconst log = debug('starling:oauth-service')\n\n/**\n * Service to interact with a the oauth endpoint\n */\nclass OAuth {\n  /**\n   * Create a new oauth service\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Exchanges the authorization code for an access token\n   * @param {string} authorizationCode - the authorization code, acquired from the user agent after the user authenticates with starling\n   * @return {Promise} - the http request promise\n   */\n  getAccessToken (authorizationCode) {\n    return this.getOAuthToken({\n      queryParams: {\n        code: authorizationCode,\n        grant_type: ACCESS_TOKEN_GRANT_TYPE,\n        client_id: this.options.clientId,\n        client_secret: this.options.clientSecret,\n        redirect_uri: this.options.redirectUri\n      }\n    })\n  }\n\n  /**\n   * Exchanges the authorization code for an access token\n   * @param {string} refreshToken - the oauth refresh token, used when the access token expires to claim a new access token.\n   * @return {Promise} - the http request promise\n   */\n  refreshAccessToken (refreshToken) {\n    return this.getOAuthToken({\n      queryParams: {\n        refresh_token: refreshToken,\n        grant_type: REFRESH_TOKEN_GRANT_TYPE,\n        client_id: this.options.clientId,\n        client_secret: this.options.clientSecret\n      }\n    })\n  }\n\n  /**\n   * Gets the access token from the starling OAuth endpoint\n   * @param {string} parameters.apiUrl - the OAuth url\n   * @param {object} parameters.queryParams - the query params passed to the OAuth endpoint as per the OAuth spec\n   * @return {Promise} - the http request promise\n   */\n  getOAuthToken (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getOAuthTokenParameterValidator(parameters)\n    const { apiUrl, queryParams } = parameters\n\n    const url = `${apiUrl}/oauth/access-token`\n    log(`POST ${url} queryParams:${JSON.stringify(queryParams)}`)\n\n    return axios({\n      url,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Accept: 'application/json'\n      },\n      params: queryParams\n    })\n  }\n}\n\nconst getOAuthTokenParameterValidator = struct.interface({\n  apiUrl: 'string',\n  queryParams: struct.union([\n    struct.object({\n      client_id: 'string',\n      client_secret: 'string',\n      grant_type: struct.literal(ACCESS_TOKEN_GRANT_TYPE),\n      code: 'string',\n      redirect_uri: 'string'\n    }),\n    struct.object({\n      client_id: 'string',\n      client_secret: 'string',\n      grant_type: struct.literal(REFRESH_TOKEN_GRANT_TYPE),\n      refresh_token: 'string'\n    })\n  ])\n})\n\nmodule.exports = OAuth\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders, payloadHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion, minAPIParameterValidator } from '../utils/validator'\n\nconst log = debug('starling:payee-service')\n\n/**\n * Service to interact with an account holder's payees\n */\nclass Payee {\n  /**\n   * Create a new payee service\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get an account holder's payees\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @return {Promise} - the http request promise\n   */\n  getPayees (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    minAPIParameterValidator(parameters)\n    const { apiUrl, accessToken } = parameters\n\n    const url = `${apiUrl}/api/v2/payees`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Create a new payee\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @param {Object} parameters.payeeCreationRequest - the payee creation request.\n   * @return {Promise} - the http request promise\n   */\n  createPayee (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    createPayeeParameterValidator(parameters)\n    const { apiUrl, accessToken, payeeCreationRequest } = parameters\n\n    const url = `${apiUrl}/api/v2/payees`\n    log(`PUT ${url}`)\n    return axios({\n      method: 'PUT',\n      url,\n      headers: payloadHeaders(accessToken),\n      data: JSON.stringify(payeeCreationRequest)\n    })\n  }\n\n  /**\n   * Delete an account holder's payee\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token.\n   * @param {string} parameters.payeeUid - the payeeUid of the payee to be deleted.\n   * @return {Promise} - the http request promise\n   */\n  deletePayee (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    deletePayeeParameterValidator(parameters)\n    const { apiUrl, accessToken, payeeUid } = parameters\n\n    const url = `${apiUrl}/api/v2/payees/${payeeUid}`\n    log(`DELETE ${url}`)\n    return axios({\n      method: 'DELETE',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nconst createPayeeParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  payeeCreationRequest: struct.object({\n    payeeName: 'string',\n    phoneNumber: 'string?',\n    payeeType: struct.enum(['INDIVIDUAL', 'BUSINESS']),\n    firstName: 'string?',\n    middleName: 'string?',\n    lastName: 'string?',\n    businessName: 'string?',\n    dateOfBirth: 'date?',\n    accounts: struct.optional([struct.object({\n      description: 'string',\n      defaultAccount: 'boolean',\n      countryCode: 'string',\n      accountIdentifier: 'string',\n      bankIdentifier: 'string',\n      bankIdentifierType: struct.enum(['SORT_CODE', 'SWIFT', 'IBAN', 'ABA', 'ABA_WIRE', 'ABA_ACH'])\n    })])\n  })\n})\n\nconst deletePayeeParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  payeeUid: 'uuid'\n})\n\nmodule.exports = Payee\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion } from '../utils/validator'\n\nconst log = debug('starling:payment-service')\n\n/**\n * Service to interact with a customer's payments\n */\nclass Payment {\n  /**\n   * Create a new payment service\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get a payment order\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.paymentOrderUid - the payment order uid\n   * @return {Promise} - the http request promise\n   */\n  getPaymentOrder (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getPaymentOrderParameterValidator(parameters)\n    const { apiUrl, accessToken, paymentOrderUid } = parameters\n\n    const url = `${apiUrl}/api/v2/payments/local/payment-order/${paymentOrderUid}`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a payment order's payments\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.paymentOrderUid - the payment order uid\n   * @return {Promise} - the http request promise\n   */\n  getPaymentOrderPayments (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getPaymentOrderPaymentsParameterValidator(parameters)\n    const { apiUrl, accessToken, paymentOrderUid } = parameters\n\n    const url = `${apiUrl}/api/v2/payments/local/payment-order/${paymentOrderUid}/payments`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * List standing orders\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid of the account to get standing orders of\n   * @param {string} parameters.categoryUid - the category uid of the category to get standing orders of\n   * @return {Promise} - the http request promise\n   */\n  listStandingOrders (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    listStandingOrdersParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, categoryUid } = parameters\n\n    const url = `${apiUrl}/api/v2/payments/local/account/${accountUid}/category/${categoryUid}/standing-orders`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a standing order\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid of the standing order\n   * @param {string} parameters.categoryUid - the category uid of the standing order\n   * @param {string} parameters.paymentOrderUid - the payment order uid of the standing order\n   * @return {Promise} - the http request promise\n   */\n  getStandingOrder (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getStandingOrderParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, categoryUid, paymentOrderUid } = parameters\n\n    const url = `${apiUrl}/api/v2/payments/local/account/${accountUid}/category/${categoryUid}/standing-orders/${paymentOrderUid}`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n}\n\nconst getPaymentOrderParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  paymentOrderUid: 'uuid'\n})\n\nconst getPaymentOrderPaymentsParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  paymentOrderUid: 'uuid'\n})\n\nconst listStandingOrdersParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  categoryUid: 'uuid'\n})\n\nconst getStandingOrderParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  categoryUid: 'uuid',\n  paymentOrderUid: 'uuid'\n})\n\nmodule.exports = Payment\n","import axios from 'axios'\nimport debug from 'debug'\nimport { defaultHeaders, payloadHeaders } from '../utils/http'\nimport { struct, minAPIParameterDefintion } from '../utils/validator'\n\nconst log = debug('starling:savings-goal-service')\n\n/**\n * Service to interact with a customer's savings goals\n */\nclass SavingsGoal {\n  /**\n   * Create a new savings goal service\n   * @param {Object} options - configuration parameters\n   */\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * Get all savings goals\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @return {Promise} - the http request promise\n   */\n  getSavingsGoals (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getSavingsGoalsParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid } = parameters\n\n    const url = `${apiUrl}/api/v2/account/${accountUid}/savings-goals`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Get a savings goal\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.savingsGoalUid - the savings goal's uid\n   * @return {Promise} - the http request promise\n   */\n  getSavingsGoal (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    getSavingsGoalParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, savingsGoalUid } = parameters\n\n    const url = `${apiUrl}/api/v2/account/${accountUid}/savings-goals/${savingsGoalUid}`\n    log(`GET ${url}`)\n\n    return axios({\n      method: 'GET',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Create a savings goal\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid of the account to create the savings goal in\n   * @param {string} parameters.name - the name of the new savings goal\n   * @param {string=} parameters.currency - ISO-4217 3 character currency code\n   * @param {number=} parameters.targetAmount - the target amount in minor units (e.g. 1234 => £12.34)\n   * @param {string=} parameters.targetCurrency - ISO-4217 3 character currency code\n   * @param {string=} parameters.base64EncodedPhoto - base64 encoded image to associate with the goal\n   * @return {Promise} - the http request promise\n   */\n  createSavingsGoal (parameters) {\n    parameters = Object.assign({}, { currency: 'GBP', targetAmount: 0, targetCurrency: 'GBP' }, this.options, parameters)\n    createSavingsGoalParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, name, currency, targetAmount, targetCurrency, base64EncodedPhoto } = parameters\n\n    const url = `${apiUrl}/api/v2/account/${accountUid}/savings-goals`\n    log(`PUT ${url}`)\n\n    return axios({\n      method: 'PUT',\n      url,\n      headers: payloadHeaders(accessToken),\n      data: JSON.stringify({\n        name,\n        currency,\n        target: {\n          minorUnits: targetAmount,\n          currency: targetCurrency\n        },\n        base64EncodedPhoto\n      })\n    })\n  }\n\n  /**\n   * Delete a savings goal\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.savingsGoalUid - the savings goal's uid\n   * @return {Promise} - the http request promise\n   */\n  deleteSavingsGoal (parameters) {\n    parameters = Object.assign({}, this.options, parameters)\n    deleteSavingsGoalParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, savingsGoalUid } = parameters\n\n    const url = `${apiUrl}/api/v2/account/${accountUid}/savings-goals/${savingsGoalUid}`\n    log(`DELETE ${url}`)\n\n    return axios({\n      method: 'DELETE',\n      url,\n      headers: defaultHeaders(accessToken)\n    })\n  }\n\n  /**\n   * Add money to a savings goal\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.savingsGoalUid - the savings goal's uid\n   * @param {string} parameters.transferUid - a transaction ID for this transaction\n   * @param {number} parameters.amount - amount in the minor units of the given currency; eg pence in GBP, cents in EUR\n   * @param {string=} parameters.currency - ISO-4217 3 character currency code\n   * @return {Promise} - the http request promise\n   */\n  addMoneyToSavingsGoal (parameters) {\n    parameters = Object.assign({}, { currency: 'GBP' }, this.options, parameters)\n    addMoneyToSavingsGoalParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, savingsGoalUid, transferUid, amount, currency } = parameters\n\n    const url = `${apiUrl}/api/v2/account/${accountUid}/savings-goals/${savingsGoalUid}/add-money/${transferUid}`\n    log(`PUT ${url}`)\n\n    return axios({\n      method: 'PUT',\n      url,\n      headers: payloadHeaders(accessToken),\n      data: JSON.stringify({\n        amount: {\n          currency,\n          minorUnits: amount\n        }\n      })\n    })\n  }\n\n  /**\n   * Withdraw money from a savings goal\n   * @param {string} parameters.apiUrl - the API URL\n   * @param {string} parameters.accessToken - the oauth bearer token\n   * @param {string} parameters.accountUid - the account uid\n   * @param {string} parameters.savingsGoalUid - the savings goal's uid\n   * @param {string} parameters.transferUid - a transaction ID for this transaction\n   * @param {number} parameters.amount - amount in the minor units of the given currency; eg pence in GBP, cents in EUR\n   * @param {string=} parameters.currency - ISO-4217 3 character currency code\n   * @return {Promise} - the http request promise\n   */\n  withdrawMoneyFromSavingsGoal (parameters) {\n    parameters = Object.assign({}, { currency: 'GBP' }, this.options, parameters)\n    withdrawMoneyFromSavingsGoalParameterValidator(parameters)\n    const { apiUrl, accessToken, accountUid, savingsGoalUid, transferUid, amount, currency } = parameters\n\n    const url = `${apiUrl}/api/v2/account/${accountUid}/savings-goals/${savingsGoalUid}/withdraw-money/${transferUid}`\n    log(`PUT ${url}`)\n\n    return axios({\n      method: 'PUT',\n      url,\n      headers: payloadHeaders(accessToken),\n      data: JSON.stringify({\n        amount: {\n          currency,\n          minorUnits: amount\n        }\n      })\n    })\n  }\n}\n\nconst getSavingsGoalsParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid'\n})\n\nconst getSavingsGoalParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  savingsGoalUid: 'uuid'\n})\n\nconst deleteSavingsGoalParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  savingsGoalUid: 'uuid'\n})\n\nconst createSavingsGoalParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  name: 'string',\n  currency: 'string',\n  targetAmount: 'number',\n  targetCurrency: 'string',\n  base64EncodedPhoto: 'string?'\n})\n\nconst addMoneyToSavingsGoalParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  savingsGoalUid: 'uuid',\n  transferUid: 'uuid',\n  amount: 'number',\n  currency: 'string'\n})\n\nconst withdrawMoneyFromSavingsGoalParameterValidator = struct.interface({\n  ...minAPIParameterDefintion,\n  accountUid: 'uuid',\n  savingsGoalUid: 'uuid',\n  transferUid: 'uuid',\n  amount: 'number',\n  currency: 'string'\n})\n\nmodule.exports = SavingsGoal\n","import Account from './entities/account'\nimport AccountHolder from './entities/accountHolder'\nimport Address from './entities/address'\nimport FeedItem from './entities/feedItem'\nimport Card from './entities/card'\nimport OAuth from './entities/oauth'\nimport Payee from './entities/payee'\nimport Payment from './entities/payment'\nimport Mandate from './entities/mandate'\nimport SavingsGoal from './entities/savingsGoal'\nimport Identity from './entities/identity'\n\n/**\n * @property {Identity} identity\n * @property {AccountHolder} accountHolder\n * @property {Account} account\n * @property {Address} address\n * @property {FeedItem} feedItem\n * @property {Payment} payment\n * @property {Mandate} mandate\n * @property {Payee} payee\n * @property {Card} card\n * @property {SavingsGoal} savingsGoal\n * @property {OAuth} oAuth\n */\nclass Starling {\n  /**\n   * Create an instance of the starling client\n   * @param {Object=} options - configuration parameters\n   */\n  constructor (options) {\n    const defaults = {\n      apiUrl: 'https://api.starlingbank.com',\n      clientId: '',\n      clientSecret: ''\n    }\n\n    this.config = Object.assign({}, defaults, options)\n\n    this.identity = new Identity(this.config)\n    this.accountHolder = new AccountHolder(this.config)\n    this.account = new Account(this.config)\n    this.address = new Address(this.config)\n    this.feedItem = new FeedItem(this.config)\n    this.payment = new Payment(this.config)\n    this.mandate = new Mandate(this.config)\n    this.payee = new Payee(this.config)\n    this.card = new Card(this.config)\n    this.savingsGoal = new SavingsGoal(this.config)\n    this.oAuth = new OAuth(this.config)\n  }\n}\n\nmodule.exports = Starling\n","export const defaultHeaders = (accessToken) => ({\n  Accept: 'application/json',\n  Authorization: `Bearer ${accessToken}`\n})\n\nexport const payloadHeaders = (accessToken) => ({\n  ...defaultHeaders(accessToken),\n  'Content-Type': 'application/json'\n})\n","const superstruct = require('superstruct').superstruct\nexport const struct = superstruct({\n  types: {\n    uuid: value => /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value),\n    yearMonth: value => /^[0-9]{4}-(?:1[0-2]|0[1-9])$/.test(value),\n    date: value => /^[0-9]{4}-(?:1[0-2]|0[1-9])-(?:3[01]|[12]\\d|0[1-9])$/.test(value),\n    timestamp: value => /^((?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\\.[0-9]+)?(Z)?$/.test(value)\n  }\n})\nexport const minAPIParameterDefintion = { accessToken: 'string', apiUrl: 'string' }\nexport const minAPIParameterValidator = struct.interface(minAPIParameterDefintion)\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguY2pzIiwic3JjL2VudGl0aWVzL2FjY291bnQuanMiLCJzcmMvZW50aXRpZXMvYWNjb3VudEhvbGRlci5qcyIsInNyYy9lbnRpdGllcy9hZGRyZXNzLmpzIiwic3JjL2VudGl0aWVzL2NhcmQuanMiLCJzcmMvZW50aXRpZXMvZmVlZEl0ZW0uanMiLCJzcmMvZW50aXRpZXMvaWRlbnRpdHkuanMiLCJzcmMvZW50aXRpZXMvbWFuZGF0ZS5qcyIsInNyYy9lbnRpdGllcy9vYXV0aC5qcyIsInNyYy9lbnRpdGllcy9wYXllZS5qcyIsInNyYy9lbnRpdGllcy9wYXltZW50LmpzIiwic3JjL2VudGl0aWVzL3NhdmluZ3NHb2FsLmpzIiwic3JjL3N0YXJsaW5nLmpzIiwic3JjL3V0aWxzL2h0dHAuanMiLCJzcmMvdXRpbHMvdmFsaWRhdG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFjLEdBQUcsU0FBakIsY0FBaUIsQ0FBQyxXQUFEO0FBQUEsMkNBQ3pCLGNBQWMsQ0FBQyxXQUFELENBRFc7QUFFNUIsc0JBQWdCO0FBRlk7QUFBQSxHQUF2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMUCxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsYUFBRCxDQUFQLENBQXVCLFdBQTNDOztBQUNPLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQztBQUNoQyxJQUFBLEtBQUssRUFBRTtBQUNMLE1BQUEsSUFBSSxFQUFFLGNBQUEsS0FBSztBQUFBLGVBQUksMkVBQTJFLElBQTNFLENBQWdGLEtBQWhGLENBQUo7QUFBQSxPQUROO0FBRUwsTUFBQSxTQUFTLEVBQUUsbUJBQUEsS0FBSztBQUFBLGVBQUksK0JBQStCLElBQS9CLENBQW9DLEtBQXBDLENBQUo7QUFBQSxPQUZYO0FBR0wsTUFBQSxJQUFJLEVBQUUsY0FBQSxLQUFLO0FBQUEsZUFBSSx1REFBdUQsSUFBdkQsQ0FBNEQsS0FBNUQsQ0FBSjtBQUFBLE9BSE47QUFJTCxNQUFBLFNBQVMsRUFBRSxtQkFBQSxLQUFLO0FBQUEsZUFBSSxvSUFBb0ksSUFBcEksQ0FBeUksS0FBekksQ0FBSjtBQUFBO0FBSlg7QUFEeUIsR0FBRCxDQUExQjs7QUFRQSxNQUFNLHdCQUF3QixHQUFHO0FBQUUsSUFBQSxXQUFXLEVBQUUsUUFBZjtBQUF5QixJQUFBLE1BQU0sRUFBRTtBQUFqQyxHQUFqQzs7QUFDQSxNQUFNLHdCQUF3QixHQUFHLE1BQU0sYUFBTixDQUFpQix3QkFBakIsQ0FBakMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh1dGlscy5pc0Jsb2IocmVxdWVzdERhdGEpIHx8IHV0aWxzLmlzRmlsZShyZXF1ZXN0RGF0YSkpICYmXG4gICAgICByZXF1ZXN0RGF0YS50eXBlXG4gICAgKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIGtpbmRPZiA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gJ2Jvb2xlYW4nO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHJldHVybiAnc3RyaW5nJztcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gJ251bWJlcic7XG4gIGlmICh0eXBlID09PSAnc3ltYm9sJykgcmV0dXJuICdzeW1ib2wnO1xuICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpc0dlbmVyYXRvckZuKHZhbCkgPyAnZ2VuZXJhdG9yZnVuY3Rpb24nIDogJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiAnYXJyYXknO1xuICBpZiAoaXNCdWZmZXIodmFsKSkgcmV0dXJuICdidWZmZXInO1xuICBpZiAoaXNBcmd1bWVudHModmFsKSkgcmV0dXJuICdhcmd1bWVudHMnO1xuICBpZiAoaXNEYXRlKHZhbCkpIHJldHVybiAnZGF0ZSc7XG4gIGlmIChpc0Vycm9yKHZhbCkpIHJldHVybiAnZXJyb3InO1xuICBpZiAoaXNSZWdleHAodmFsKSkgcmV0dXJuICdyZWdleHAnO1xuXG4gIHN3aXRjaCAoY3Rvck5hbWUodmFsKSkge1xuICAgIGNhc2UgJ1N5bWJvbCc6IHJldHVybiAnc3ltYm9sJztcbiAgICBjYXNlICdQcm9taXNlJzogcmV0dXJuICdwcm9taXNlJztcblxuICAgIC8vIFNldCwgTWFwLCBXZWFrU2V0LCBXZWFrTWFwXG4gICAgY2FzZSAnV2Vha01hcCc6IHJldHVybiAnd2Vha21hcCc7XG4gICAgY2FzZSAnV2Vha1NldCc6IHJldHVybiAnd2Vha3NldCc7XG4gICAgY2FzZSAnTWFwJzogcmV0dXJuICdtYXAnO1xuICAgIGNhc2UgJ1NldCc6IHJldHVybiAnc2V0JztcblxuICAgIC8vIDgtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDhBcnJheSc6IHJldHVybiAnaW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OEFycmF5JzogcmV0dXJuICd1aW50OGFycmF5JztcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6IHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuXG4gICAgLy8gMTYtYml0IHR5cGVkIGFycmF5c1xuICAgIGNhc2UgJ0ludDE2QXJyYXknOiByZXR1cm4gJ2ludDE2YXJyYXknO1xuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzogcmV0dXJuICd1aW50MTZhcnJheSc7XG5cbiAgICAvLyAzMi1iaXQgdHlwZWQgYXJyYXlzXG4gICAgY2FzZSAnSW50MzJBcnJheSc6IHJldHVybiAnaW50MzJhcnJheSc7XG4gICAgY2FzZSAnVWludDMyQXJyYXknOiByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOiByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gICAgY2FzZSAnRmxvYXQ2NEFycmF5JzogcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgaWYgKGlzR2VuZXJhdG9yT2JqKHZhbCkpIHtcbiAgICByZXR1cm4gJ2dlbmVyYXRvcic7XG4gIH1cblxuICAvLyBOb24tcGxhaW4gb2JqZWN0c1xuICB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOiByZXR1cm4gJ29iamVjdCc7XG4gICAgLy8gaXRlcmF0b3JzXG4gICAgY2FzZSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJzogcmV0dXJuICdtYXBpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJzogcmV0dXJuICdzZXRpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmcgSXRlcmF0b3JdJzogcmV0dXJuICdzdHJpbmdpdGVyYXRvcic7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheSBJdGVyYXRvcl0nOiByZXR1cm4gJ2FycmF5aXRlcmF0b3InO1xuICB9XG5cbiAgLy8gb3RoZXJcbiAgcmV0dXJuIHR5cGUuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbmZ1bmN0aW9uIGN0b3JOYW1lKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHZhbC5jb25zdHJ1Y3Rvci5uYW1lIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBBcnJheTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWwpIHtcbiAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yIHx8ICh0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcicpO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiB2YWwudG9EYXRlU3RyaW5nID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5zZXREYXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc1JlZ2V4cCh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLmZsYWdzID09PSAnc3RyaW5nJ1xuICAgICYmIHR5cGVvZiB2YWwuaWdub3JlQ2FzZSA9PT0gJ2Jvb2xlYW4nXG4gICAgJiYgdHlwZW9mIHZhbC5tdWx0aWxpbmUgPT09ICdib29sZWFuJ1xuICAgICYmIHR5cGVvZiB2YWwuZ2xvYmFsID09PSAnYm9vbGVhbic7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yRm4obmFtZSwgdmFsKSB7XG4gIHJldHVybiBjdG9yTmFtZShuYW1lKSA9PT0gJ0dlbmVyYXRvckZ1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmoodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRocm93ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIHZhbC5yZXR1cm4gPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgdmFsLm5leHQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbCkge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgdmFsLmxlbmd0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbC5jYWxsZWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ2NhbGxlZScpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IFNhZmFyaSA1LTcgKDgtMTAgeXItb2xkIGJyb3dzZXIpLFxuICogdGFrZSBhIGxvb2sgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pcy1idWZmZXJcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXHJcbiAqIFN1cGVyc3RydWN0IHNoaXBzIGJ5IGRlZmF1bHQgd2l0aCBhbiB1bm9waW5pb25hdGVkIHNldCBvZiBzY2FsYXIgdHlwZXMgdGhhdFxyXG4gKiBleHByZXNzIGFsbCBvZiB0aGUgZGF0YSB0eXBlcyB0aGF0IGFyZSBidWlsdC1pbiB0byBKYXZhU2NyaXB0LlxyXG4gKi9cblxudmFyIFR5cGVzID0ge1xuICAvKipcclxuICAgKiBNYXRjaGVzIGFueSB2YWx1ZSBvdGhlciB0aGFuIGB1bmRlZmluZWRgLlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiAnYW55dGhpbmcnXHJcbiAgICogdHJ1ZVxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBhbnk6IGZ1bmN0aW9uIGFueSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBhcmd1bWVudHNcclxuICAgKiBgYGBcclxuICAgKi9cbiAgYXJndW1lbnRzOiBmdW5jdGlvbiBfYXJndW1lbnRzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdhcmd1bWVudHMnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYW4gYEFycmF5YC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogWzEsIDIsIDNdXHJcbiAgICogYGBgXHJcbiAgICovXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnYXJyYXknO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBib29sZWFuLlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB0cnVlXHJcbiAgICogZmFsc2VcclxuICAgKiBgYGBcclxuICAgKi9cbiAgYm9vbGVhbjogZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnYm9vbGVhbic7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIE5vZGUuanMgYEJ1ZmZlcmAuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIEJ1ZmZlci5mcm9tKCdzdHJpbmcnKVxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBidWZmZXI6IGZ1bmN0aW9uIGJ1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnYnVmZmVyJztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgKip2YWxpZCoqIGBEYXRlYCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG5ldyBEYXRlKClcclxuICAgKiBgYGBcclxuICAgKlxyXG4gICAqIE5vdGU6IEludmFsaWQgYERhdGVgIG9iamVjdHMgdGhhdCBlcXVhbCBgTmFOYCBhcmUgbm90IG1hdGNoZWQuXHJcbiAgICovXG4gIGRhdGU6IGZ1bmN0aW9uIGRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ2RhdGUnICYmICFpc05hTih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhbiBlcnJvciBvYmplY3QuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIG5ldyBFcnJvcigpXHJcbiAgICogYGBgXHJcbiAgICovXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnZXJyb3InO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgRmxvYXQzMkFycmF5YCBvYmplY3QuXHJcbiAgICovXG4gIGZsb2F0MzJhcnJheTogZnVuY3Rpb24gZmxvYXQzMmFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdmbG9hdDMyYXJyYXknO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgRmxvYXQ2NEFycmF5YCBvYmplY3QuXHJcbiAgICovXG4gIGZsb2F0NjRhcnJheTogZnVuY3Rpb24gZmxvYXQ2NGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdmbG9hdDY0YXJyYXknO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogKCkgPT4ge31cclxuICAgKiBmdW5jdGlvbiAoKSB7fVxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBmdW5jdGlvbjogZnVuY3Rpb24gX2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdmdW5jdGlvbic7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIGdlbmVyYXRvciBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogZnVuY3Rpb24qICgpIHt9XHJcbiAgICogYGBgXHJcbiAgICovXG4gIGdlbmVyYXRvcmZ1bmN0aW9uOiBmdW5jdGlvbiBnZW5lcmF0b3JmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnZ2VuZXJhdG9yZnVuY3Rpb24nO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgSW50MTZBcnJheWAgb2JqZWN0LlxyXG4gICAqL1xuICBpbnQxNmFycmF5OiBmdW5jdGlvbiBpbnQxNmFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdpbnQxNmFycmF5JztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgYEludDMyQXJyYXlgIG9iamVjdC5cclxuICAgKi9cbiAgaW50MzJhcnJheTogZnVuY3Rpb24gaW50MzJhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnaW50MzJhcnJheSc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIGBJbnQ4QXJyYXlgIG9iamVjdC5cclxuICAgKi9cbiAgaW50OGFycmF5OiBmdW5jdGlvbiBpbnQ4YXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ2ludDhhcnJheSc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIGBNYXBgIG9iamVjdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogbmV3IE1hcCgpXHJcbiAgICogYGBgXHJcbiAgICovXG4gIG1hcDogZnVuY3Rpb24gbWFwKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdtYXAnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgdGhlIGBudWxsYCBsaXRlcmFsIHZhbHVlLlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBudWxsXHJcbiAgICogYGBgXHJcbiAgICovXG4gIG51bGw6IGZ1bmN0aW9uIF9udWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdudWxsJztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiA0MlxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnbnVtYmVyJztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgcGxhaW4gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiB7IGtleTogJ3ZhbHVlJyB9XHJcbiAgICogeyBzb21ldGhpbmc6IHRydWUgfVxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAnb2JqZWN0JztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgYFByb21pc2VgIG9iamVjdC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogUHJvbWlzZS5yZXNvbHZlKClcclxuICAgKiBgYGBcclxuICAgKi9cbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAncHJvbWlzZSc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIC9hLXovZ1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICByZWdleHA6IGZ1bmN0aW9uIHJlZ2V4cCh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAncmVnZXhwJztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgYFNldGAgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBuZXcgU2V0KClcclxuICAgKiBgYGBcclxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ3NldCc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogJ3RleHQnXHJcbiAgICogYGBgXHJcbiAgICovXG4gIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICdzdHJpbmcnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgU3ltYm9sYC5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogU3ltYm9sKClcclxuICAgKiBgYGBcclxuICAgKi9cbiAgc3ltYm9sOiBmdW5jdGlvbiBzeW1ib2wodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ3N5bWJvbCc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWF0Y2hlcyBhIGBVaW50MTZBcnJheWAgb2JqZWN0LlxyXG4gICAqL1xuICB1aW50MTZhcnJheTogZnVuY3Rpb24gdWludDE2YXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ3VpbnQxNmFycmF5JztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgYFVpbnQzMkFycmF5YCBvYmplY3QuXHJcbiAgICovXG4gIHVpbnQzMmFycmF5OiBmdW5jdGlvbiB1aW50MzJhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAndWludDMyYXJyYXknO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgVWludDhBcnJheWAgb2JqZWN0LlxyXG4gICAqL1xuICB1aW50OGFycmF5OiBmdW5jdGlvbiB1aW50OGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICd1aW50OGFycmF5JztcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaGVzIGEgYFVpbnQ4Q2xhbXBlZEFycmF5YCBvYmplY3QuXHJcbiAgICovXG4gIHVpbnQ4Y2xhbXBlZGFycmF5OiBmdW5jdGlvbiB1aW50OGNsYW1wZWRhcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBraW5kT2YodmFsdWUpID09PSAndWludDhjbGFtcGVkYXJyYXknO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgdGhlIGB1bmRlZmluZWRgIGxpdGVyYWwgdmFsdWUuXHJcbiAgICpcclxuICAgKiBgYGBqc1xyXG4gICAqIHVuZGVmaW5lZFxyXG4gICAqIGBgYFxyXG4gICAqL1xuICB1bmRlZmluZWQ6IGZ1bmN0aW9uIHVuZGVmaW5lZCQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIGtpbmRPZih2YWx1ZSkgPT09ICd1bmRlZmluZWQnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgV2Vha01hcGAgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBuZXcgV2Vha01hcCgpXHJcbiAgICogYGBgXHJcbiAgICovXG4gIHdlYWttYXA6IGZ1bmN0aW9uIHdlYWttYXAodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ3dlYWttYXAnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1hdGNoZXMgYSBgV2Vha1NldGAgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogYGBganNcclxuICAgKiBuZXcgV2Vha1NldCgpXHJcbiAgICogYGBgXHJcbiAgICovXG4gIHdlYWtzZXQ6IGZ1bmN0aW9uIHdlYWtzZXQodmFsdWUpIHtcbiAgICByZXR1cm4ga2luZE9mKHZhbHVlKSA9PT0gJ3dlYWtzZXQnO1xuICB9XG59O1xuXG52YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbnZhciBwcmVmaXggPSAnSW52YXJpYW50IGZhaWxlZCc7XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8ICcnKSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgYnkgU3VwZXJzdHJ1Y3Qgd2hlbiBpdHNcclxuICogdmFsaWRhdGlvbiBmYWlscy4gVGhlIGVycm9yIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZ1xyXG4gKiB2YWxpZGF0aW9uLiBCdXQgdGhleSBhbHNvIGhhdmUgYW4gYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSB0aGF0IGhvbGRzXHJcbiAqIGluZm9ybWF0aW9uIGZvciBhbGwgb2YgdGhlIGZhaWx1cmVzIGVuY291bnRlcmVkLlxyXG4gKi9cblxudmFyIFN0cnVjdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHlwZUVycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0cnVjdEVycm9yLCBfVHlwZUVycm9yKTtcblxuICBmdW5jdGlvbiBTdHJ1Y3RFcnJvcihmYWlsdXJlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGludmFyaWFudChmYWlsdXJlcy5sZW5ndGggPiAwLCBcIlN0cnVjdEVycm9yIHJlcXVpcmVzIGJlaW5nIHBhc3NlZCBhIGZhaWx1cmUsIGJ1dCByZWNlaXZlZDogXCIgKyBmYWlsdXJlcyk7XG4gICAgdmFyIGZpcnN0ID0gZmFpbHVyZXNbMF07XG5cbiAgICB2YXIgcGF0aCA9IGZpcnN0LnBhdGgsXG4gICAgICAgIHZhbHVlID0gZmlyc3QudmFsdWUsXG4gICAgICAgIHR5cGUgPSBmaXJzdC50eXBlLFxuICAgICAgICBicmFuY2ggPSBmaXJzdC5icmFuY2gsXG4gICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShmaXJzdCwgW1wicGF0aFwiLCBcInZhbHVlXCIsIFwidHlwZVwiLCBcImJyYW5jaFwiXSk7XG5cbiAgICB2YXIgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIGBcIiArIHR5cGUgKyBcImBcIiArIChwYXRoLmxlbmd0aCA/IFwiIGZvciBgXCIgKyBwYXRoLmpvaW4oJy4nKSArIFwiYFwiIDogJycpICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIFwiYC5cIjtcbiAgICBfdGhpcyA9IF9UeXBlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgT2JqZWN0LmFzc2lnbihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgcmVzdCk7XG4gICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgX3RoaXMuYnJhbmNoID0gYnJhbmNoO1xuICAgIF90aGlzLmZhaWx1cmVzID0gZmFpbHVyZXM7XG4gICAgX3RoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICBfdGhpcy5fX3Byb3RvX18gPSBTdHJ1Y3RFcnJvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFN0cnVjdEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoVHlwZUVycm9yKSk7XG5cbi8qKlxyXG4gKiBBIHN5bWJvbCB0byBzZXQgb24gYFN0cnVjdGAgb2JqZWN0cyB0byB0ZXN0IHRoZW0gYWdhaW5zdCBsYXRlci5cclxuICovXG52YXIgU1RSVUNUID0gU3ltYm9sKCdTVFJVQ1QnKTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFN0cnVjdGAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGlzU3RydWN0ID0gZnVuY3Rpb24gaXNTdHJ1Y3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZVtTVFJVQ1RdO1xufTtcbi8qKlxyXG4gKiBUaGlzIGFic3RyYWN0IGBTdHJ1Y3RgIGZhY3RvcnkgY3JlYXRlcyBhIGdlbmVyaWMgc3RydWN0IHRoYXQgdmFsaWRhdGVzIHZhbHVlc1xyXG4gKiBhZ2FpbnN0IGEgYFZhbGlkYXRvcmAgZnVuY3Rpb24uXHJcbiAqL1xuXG52YXIgY3JlYXRlU3RydWN0ID0gZnVuY3Rpb24gY3JlYXRlU3RydWN0KHByb3BzKSB7XG4gIHZhciBzdHJ1Y3QgPSBwcm9wcy5zdHJ1Y3Q7XG4gIHZhciBFcnJvciA9IHN0cnVjdC5FcnJvcjtcblxuICB2YXIgU3RydWN0ID0gZnVuY3Rpb24gU3RydWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIFN0cnVjdC5hc3NlcnQodmFsdWUpO1xuICB9OyAvLyBTZXQgYSBoaWRkZW4gc3ltYm9sIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGNoZWNrIGl0IGxhdGVyIHRvIHNlZSBpZiBhblxuICAvLyBvYmplY3QgaXMgYSBzdHJ1Y3Qgb2JqZWN0LlxuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cnVjdCwgU1RSVUNULCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIFN0cnVjdC5raW5kID0gcHJvcHMua2luZDtcbiAgU3RydWN0LnR5cGUgPSBwcm9wcy50eXBlO1xuXG4gIFN0cnVjdC5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuZGVmYXVsdHMgPT09ICdmdW5jdGlvbicgPyBwcm9wcy5kZWZhdWx0cygpIDogcHJvcHMuZGVmYXVsdHM7XG4gIH07XG5cbiAgU3RydWN0LnRlc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgX1N0cnVjdCRjaGVjayA9IFN0cnVjdC5jaGVjayh2YWx1ZSwgW3ZhbHVlXSwgW10pLFxuICAgICAgICBmYWlsdXJlcyA9IF9TdHJ1Y3QkY2hlY2tbMF07XG5cbiAgICByZXR1cm4gIWZhaWx1cmVzO1xuICB9O1xuXG4gIFN0cnVjdC5hc3NlcnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgX1N0cnVjdCRjaGVjazIgPSBTdHJ1Y3QuY2hlY2sodmFsdWUsIFt2YWx1ZV0sIFtdKSxcbiAgICAgICAgZmFpbHVyZXMgPSBfU3RydWN0JGNoZWNrMlswXSxcbiAgICAgICAgcmVzdWx0ID0gX1N0cnVjdCRjaGVjazJbMV07XG5cbiAgICBpZiAoZmFpbHVyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWlsdXJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIFN0cnVjdC52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfU3RydWN0JGNoZWNrMyA9IFN0cnVjdC5jaGVjayh2YWx1ZSwgW3ZhbHVlXSwgW10pLFxuICAgICAgICBmYWlsdXJlcyA9IF9TdHJ1Y3QkY2hlY2szWzBdLFxuICAgICAgICByZXN1bHQgPSBfU3RydWN0JGNoZWNrM1sxXTtcblxuICAgIGlmIChmYWlsdXJlcykge1xuICAgICAgcmV0dXJuIFtuZXcgRXJyb3IoZmFpbHVyZXMpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHJlc3VsdF07XG4gICAgfVxuICB9O1xuXG4gIFN0cnVjdC5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYnJhbmNoLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gU3RydWN0LmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgZmFpbHVyZXMgPSBbU3RydWN0LmZhaWwoe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnJhbmNoOiBicmFuY2gsXG4gICAgICBwYXRoOiBwYXRoXG4gICAgfSldO1xuICAgIHJldHVybiBbZmFpbHVyZXNdO1xuICB9O1xuXG4gIFN0cnVjdC5mYWlsID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb2JqKSwge30sIHtcbiAgICAgIHR5cGU6ICd0eXBlJyBpbiBvYmogPyBvYmoudHlwZSA6IFN0cnVjdC50eXBlXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0cnVjdDtcbn07XG5cbnZhciBjcmVhdGVBcnJheSA9IGZ1bmN0aW9uIGNyZWF0ZUFycmF5KHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzY2hlbWEpICYmIHNjaGVtYS5sZW5ndGggPT09IDEsIFwiQXJyYXkgc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXkgd2l0aCBvbmUgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcbiAgdmFyIEVsZW1lbnQgPSBzdHJ1Y3Qoc2NoZW1hWzBdLCB1bmRlZmluZWQpO1xuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAnYXJyYXknLFxuICAgIHR5cGU6IEVsZW1lbnQudHlwZSArIFwiW11cIixcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgc3RydWN0OiBzdHJ1Y3RcbiAgfSk7XG5cbiAgU3RydWN0LmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlLCBicmFuY2gsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBTdHJ1Y3QuZGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbW1N0cnVjdC5mYWlsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBicmFuY2g6IGJyYW5jaCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSldXTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGZhaWx1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlW2ldO1xuXG4gICAgICB2YXIgX0VsZW1lbnQkY2hlY2sgPSBFbGVtZW50LmNoZWNrKHYsIGJyYW5jaC5jb25jYXQodiksIHBhdGguY29uY2F0KGkpKSxcbiAgICAgICAgICBlZnMgPSBfRWxlbWVudCRjaGVja1swXSxcbiAgICAgICAgICBlciA9IF9FbGVtZW50JGNoZWNrWzFdO1xuXG4gICAgICBpZiAoZWZzKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2guYXBwbHkoZmFpbHVyZXMsIGVmcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbaV0gPSBlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFpbHVyZXMubGVuZ3RoID8gW2ZhaWx1cmVzXSA6IFt1bmRlZmluZWQsIHJlc3VsdF07XG4gIH07XG5cbiAgcmV0dXJuIFN0cnVjdDtcbn07XG5cbnZhciBjcmVhdGVEeW5hbWljID0gZnVuY3Rpb24gY3JlYXRlRHluYW1pYyhzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpIHtcbiAgaW52YXJpYW50KHR5cGVvZiBzY2hlbWEgPT09ICdmdW5jdGlvbicsIFwiRHluYW1pYyBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uLCBidXQgeW91IHBhc3NlZDogXCIgKyBzY2hlbWEpO1xuICB2YXIgRHluYW1pYyA9IGNyZWF0ZVN0cnVjdCh7XG4gICAga2luZDogJ2R5bmFtaWMnLFxuICAgIHR5cGU6IFwiZHluYW1pYzxcXHUyMDI2PlwiLFxuICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICBzdHJ1Y3Q6IHN0cnVjdFxuICB9KTtcblxuICBEeW5hbWljLmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlLCBicmFuY2gsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBEeW5hbWljLmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgU3RydWN0ID0gc2NoZW1hKHZhbHVlLCBicmFuY2gsIHBhdGgpO1xuICAgIHJldHVybiBTdHJ1Y3QuY2hlY2sodmFsdWUsIGJyYW5jaCwgcGF0aCk7XG4gIH07XG5cbiAgcmV0dXJuIER5bmFtaWM7XG59O1xuXG52YXIgY3JlYXRlRW51bSA9IGZ1bmN0aW9uIGNyZWF0ZUVudW0oc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KSB7XG4gIGludmFyaWFudChBcnJheS5pc0FycmF5KHNjaGVtYSksIFwiRW51bSBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSwgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcblxuICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5pbmNsdWRlcyh2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIFN0cnVjdCA9IHN0cnVjdCh2YWxpZGF0b3IsIGRlZmF1bHRzKTtcbiAgU3RydWN0LmtpbmQgPSAnZW51bSc7XG4gIFN0cnVjdC50eXBlID0gc2NoZW1hLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgPyBcIlxcXCJcIiArIHMgKyBcIlxcXCJcIiA6IFwiXCIgKyBzO1xuICB9KS5qb2luKCcgfCAnKTtcbiAgcmV0dXJuIFN0cnVjdDtcbn07XG5cbnZhciBjcmVhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAnZnVuY3Rpb24nLFxuICAgIHR5cGU6IFwiZnVuY3Rpb248XFx1MjAyNj5cIixcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgc3RydWN0OiBzdHJ1Y3RcbiAgfSk7XG5cbiAgU3RydWN0LmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlLCBicmFuY2gsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBTdHJ1Y3QuZGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBzY2hlbWEodmFsdWUsIGJyYW5jaCwgcGF0aCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdmFsdWVdO1xuICAgIH1cblxuICAgIHZhciBmYWlsdXJlcyA9IFtdO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIGZhaWx1cmVzLnB1c2goU3RydWN0LmZhaWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJyYW5jaDogYnJhbmNoLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocmVzdWx0KSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgZmFpbHVyZXMucHVzaChTdHJ1Y3QuZmFpbChfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGJyYW5jaDogYnJhbmNoLFxuICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfSwgcikpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmYWlsdXJlcy5wdXNoKFN0cnVjdC5mYWlsKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBicmFuY2g6IGJyYW5jaCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSwgcmVzdWx0KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVmFsaWRhdG9yIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIGJvb2xlYW4sIGEgZmFpbHVyZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIGZhaWx1cmUgb2JqZWN0cywgYnV0IHlvdSBwYXNzZWQ6IFwiICsgcmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2ZhaWx1cmVzXTtcbiAgfTtcblxuICByZXR1cm4gU3RydWN0O1xufTtcblxudmFyIGNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2Uoc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KSB7XG4gIGludmFyaWFudCh0eXBlb2Ygc2NoZW1hID09PSAnZnVuY3Rpb24nLCBcIkluc3RhbmNlIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB5b3UgcGFzc2VkOiBcIiArIHNjaGVtYSk7XG5cbiAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIHNjaGVtYTtcbiAgfTtcblxuICB2YXIgU3RydWN0ID0gc3RydWN0KHZhbGlkYXRvciwgZGVmYXVsdHMpO1xuICBTdHJ1Y3Qua2luZCA9ICdpbnN0YW5jZSc7XG4gIFN0cnVjdC50eXBlID0gXCJpbnN0YW5jZTxcIiArIHNjaGVtYS5uYW1lICsgXCI+XCI7XG4gIHJldHVybiBTdHJ1Y3Q7XG59O1xuXG52YXIgY3JlYXRlSW50ZXJmYWNlID0gZnVuY3Rpb24gY3JlYXRlSW50ZXJmYWNlKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICBpbnZhcmlhbnQodHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcsIFwiSW50ZXJmYWNlIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcbiAgdmFyIFByb3BzID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgIFByb3BzW2tleV0gPSBzdHJ1Y3Qoc2NoZW1hW2tleV0pO1xuICB9XG5cbiAgdmFyIFN0cnVjdCA9IGNyZWF0ZVN0cnVjdCh7XG4gICAga2luZDogJ2ludGVyZmFjZScsXG4gICAgdHlwZTogXCJpbnRlcmZhY2U8e1wiICsgT2JqZWN0LmtleXMoc2NoZW1hKS5qb2luKCkgKyBcIn0+XCIsXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIHN0cnVjdDogc3RydWN0XG4gIH0pO1xuXG4gIFN0cnVjdC5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYnJhbmNoLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gU3RydWN0LmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBbW1N0cnVjdC5mYWlsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBicmFuY2g6IGJyYW5jaCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSldXTtcbiAgICB9XG5cbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGsgaW4gUHJvcHMpIHtcbiAgICAgIHZhciBQcm9wID0gUHJvcHNba107XG4gICAgICB2YXIgdiA9IHZhbHVlW2tdO1xuXG4gICAgICB2YXIgX1Byb3AkY2hlY2sgPSBQcm9wLmNoZWNrKHYsIGJyYW5jaC5jb25jYXQodiksIHBhdGguY29uY2F0KGspKSxcbiAgICAgICAgICBwZnMgPSBfUHJvcCRjaGVja1swXTtcblxuICAgICAgaWYgKHBmcykge1xuICAgICAgICBmYWlsdXJlcy5wdXNoLmFwcGx5KGZhaWx1cmVzLCBwZnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWlsdXJlcy5sZW5ndGggPyBbZmFpbHVyZXNdIDogW3VuZGVmaW5lZCwgdmFsdWVdO1xuICB9O1xuXG4gIHJldHVybiBTdHJ1Y3Q7XG59O1xuXG52YXIgY3JlYXRlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlSW50ZXJzZWN0aW9uKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzY2hlbWEpICYmIHNjaGVtYS5sZW5ndGggIT09IDAsIFwiSW50ZXJzZWN0aW9uIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGEgbm9uLWVtcHR5IGFycmF5LCBidXQgeW91IHBhc3NlZDogXCIgKyBzY2hlbWEpO1xuICB2YXIgU3RydWN0cyA9IHNjaGVtYS5tYXAoZnVuY3Rpb24gKHNjaCkge1xuICAgIHJldHVybiBzdHJ1Y3Qoc2NoKTtcbiAgfSk7XG4gIHZhciB0eXBlID0gU3RydWN0cy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy50eXBlO1xuICB9KS5qb2luKCcgJiAnKTtcbiAgdmFyIFN0cnVjdCA9IGNyZWF0ZVN0cnVjdCh7XG4gICAga2luZDogJ2ludGVyc2VjdGlvbicsXG4gICAgdHlwZTogdHlwZSxcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgc3RydWN0OiBzdHJ1Y3RcbiAgfSk7XG5cbiAgU3RydWN0LmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlLCBicmFuY2gsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBTdHJ1Y3QuZGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoU3RydWN0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0cnVjdCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICB2YXIgX3N0cnVjdCRjaGVjayA9IF9zdHJ1Y3QuY2hlY2sodmFsdWUsIGJyYW5jaCwgcGF0aCksXG4gICAgICAgICAgZnMgPSBfc3RydWN0JGNoZWNrWzBdLFxuICAgICAgICAgIHYgPSBfc3RydWN0JGNoZWNrWzFdO1xuXG4gICAgICBpZiAoZnMpIHtcbiAgICAgICAgcmV0dXJuIFtbU3RydWN0LmZhaWwoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBicmFuY2g6IGJyYW5jaCxcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH0pXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICB9O1xuXG4gIHJldHVybiBTdHJ1Y3Q7XG59O1xuXG52YXIgY3JlYXRlTGF6eSA9IGZ1bmN0aW9uIGNyZWF0ZUxhenkoc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KSB7XG4gIGludmFyaWFudCh0eXBlb2Ygc2NoZW1hID09PSAnZnVuY3Rpb24nLCBcIkxhenkgc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiwgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcbiAgdmFyIExhenkgPSBjcmVhdGVTdHJ1Y3Qoe1xuICAgIGtpbmQ6ICdsYXp5JyxcbiAgICB0eXBlOiBcImxhenk8XFx1MjAyNj5cIixcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgc3RydWN0OiBzdHJ1Y3RcbiAgfSk7XG5cbiAgTGF6eS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3QuYXNzaWduKExhenksIHNjaGVtYSgpKTtcbiAgICByZXR1cm4gTGF6eS5jaGVjay5hcHBseShMYXp5LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHJldHVybiBMYXp5O1xufTtcblxudmFyIGNyZWF0ZVNpemUgPSBmdW5jdGlvbiBjcmVhdGVTaXplKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzY2hlbWEpICYmIHNjaGVtYS5sZW5ndGggPT09IDIgJiYgc2NoZW1hLmV2ZXJ5KGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJztcbiAgfSksIFwiU2l6ZSBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSB3aXRoIHR3byBudW1iZXIgZWxlbWVudHMsIGJ1dCB5b3UgcGFzc2VkOiBcIiArIHNjaGVtYSk7XG4gIHZhciBtaW4gPSBzY2hlbWFbMF0sXG4gICAgICBtYXggPSBzY2hlbWFbMV07XG5cbiAgdmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmIHZhbHVlLmxlbmd0aCA+PSBtaW4gJiYgdmFsdWUubGVuZ3RoIDw9IG1heDtcbiAgfTtcblxuICB2YXIgU3RydWN0ID0gc3RydWN0KHZhbGlkYXRvciwgZGVmYXVsdHMpO1xuICBTdHJ1Y3Qua2luZCA9ICdzaXplJztcbiAgU3RydWN0LnR5cGUgPSBcInNpemU8XCIgKyBtaW4gKyBcIixcIiArIG1heCArIFwiPlwiO1xuICByZXR1cm4gU3RydWN0O1xufTtcblxudmFyIGNyZWF0ZUxpdGVyYWwgPSBmdW5jdGlvbiBjcmVhdGVMaXRlcmFsKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICB2YXIgdmFsaWRhdG9yID0gZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBzY2hlbWE7XG4gIH07XG5cbiAgdmFyIFN0cnVjdCA9IHN0cnVjdCh2YWxpZGF0b3IsIGRlZmF1bHRzKTtcbiAgU3RydWN0LmtpbmQgPSAnbGl0ZXJhbCc7XG4gIFN0cnVjdC50eXBlID0gdHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycgPyBcIlxcXCJcIiArIHNjaGVtYSArIFwiXFxcIlwiIDogXCJcIiArIHNjaGVtYTtcbiAgcmV0dXJuIFN0cnVjdDtcbn07XG5cbnZhciBjcmVhdGVPYmplY3QgPSBmdW5jdGlvbiBjcmVhdGVPYmplY3Qoc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KSB7XG4gIGludmFyaWFudCh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgXCJPYmplY3Qgc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZDogXCIgKyBzY2hlbWEpO1xuICB2YXIgUHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgUHJvcHNba2V5XSA9IHN0cnVjdChzY2hlbWFba2V5XSk7XG4gIH1cblxuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICB0eXBlOiBcIntcIiArIE9iamVjdC5rZXlzKHNjaGVtYSkuam9pbigpICsgXCJ9XCIsXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIHN0cnVjdDogc3RydWN0XG4gIH0pO1xuXG4gIFN0cnVjdC5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYnJhbmNoLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gU3RydWN0LmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IFN0cnVjdC5kZWZhdWx0KCk7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBkO1xuICAgIH1cblxuICAgIGlmIChraW5kT2YodmFsdWUpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFtbU3RydWN0LmZhaWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJyYW5jaDogYnJhbmNoLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KV1dO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICB2YXIga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoUHJvcHMpLmNvbmNhdChPYmplY3Qua2V5cyh2YWx1ZSkpKTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uoa2V5cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgayA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIHYgPSB2YWx1ZVtrXTtcbiAgICAgIHZhciBwID0gcGF0aC5jb25jYXQoayk7XG4gICAgICB2YXIgYiA9IGJyYW5jaC5jb25jYXQodik7XG4gICAgICB2YXIgUHJvcCA9IFByb3BzW2tdO1xuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkICYmIGQgIT0gbnVsbCAmJiBrIGluIGQpIHtcbiAgICAgICAgdiA9IHR5cGVvZiBkW2tdID09PSAnZnVuY3Rpb24nID8gZFtrXSh2YWx1ZSwgYnJhbmNoLCBwYXRoKSA6IGRba107XG4gICAgICB9XG5cbiAgICAgIGlmICghKGsgaW4gUHJvcHMpKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2goU3RydWN0LmZhaWwoe1xuICAgICAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICBwYXRoOiBwLFxuICAgICAgICAgIGJyYW5jaDogdmFsdWVcbiAgICAgICAgfSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9Qcm9wJGNoZWNrID0gUHJvcC5jaGVjayh2LCBiLCBwKSxcbiAgICAgICAgICBwZnMgPSBfUHJvcCRjaGVja1swXSxcbiAgICAgICAgICBwciA9IF9Qcm9wJGNoZWNrWzFdO1xuXG4gICAgICBpZiAocGZzKSB7XG4gICAgICAgIGZhaWx1cmVzLnB1c2guYXBwbHkoZmFpbHVyZXMsIHBmcyk7XG4gICAgICB9IGVsc2UgaWYgKHByICE9PSB1bmRlZmluZWQgJiYgayBpbiBQcm9wcykge1xuICAgICAgICByZXN1bHRba10gPSBwcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFpbHVyZXMubGVuZ3RoID8gW2ZhaWx1cmVzXSA6IFt1bmRlZmluZWQsIHJlc3VsdF07XG4gIH07XG5cbiAgcmV0dXJuIFN0cnVjdDtcbn07XG5cbnZhciBjcmVhdGVQYXJ0aWFsID0gZnVuY3Rpb24gY3JlYXRlUGFydGlhbChzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpIHtcbiAgaW52YXJpYW50KHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnLCBcIlBhcnRpYWwgc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZDogXCIgKyBzY2hlbWEpO1xuICB2YXIgUHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgUHJvcHNba2V5XSA9IHN0cnVjdC51bmlvbihbc2NoZW1hW2tleV0sICd1bmRlZmluZWQnXSk7XG4gIH1cblxuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAnb2JqZWN0JyxcbiAgICB0eXBlOiBcIntcIiArIE9iamVjdC5rZXlzKHNjaGVtYSkuam9pbigpICsgXCJ9XCIsXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIHN0cnVjdDogc3RydWN0XG4gIH0pO1xuXG4gIFN0cnVjdC5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYnJhbmNoLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gU3RydWN0LmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IFN0cnVjdC5kZWZhdWx0KCk7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBkO1xuICAgIH1cblxuICAgIGlmIChraW5kT2YodmFsdWUpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFtbU3RydWN0LmZhaWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJyYW5jaDogYnJhbmNoLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KV1dO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodmFsdWUpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGsgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciB2ID0gdmFsdWVba107XG4gICAgICB2YXIgcCA9IHBhdGguY29uY2F0KGspO1xuICAgICAgdmFyIGIgPSBicmFuY2guY29uY2F0KHYpO1xuICAgICAgdmFyIFByb3AgPSBQcm9wc1trXTtcblxuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCAmJiBkICE9IG51bGwgJiYgayBpbiBkKSB7XG4gICAgICAgIHYgPSB0eXBlb2YgZFtrXSA9PT0gJ2Z1bmN0aW9uJyA/IGRba10odmFsdWUsIGJyYW5jaCwgcGF0aCkgOiBkW2tdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShrIGluIFByb3BzKSkge1xuICAgICAgICBmYWlsdXJlcy5wdXNoKFN0cnVjdC5mYWlsKHtcbiAgICAgICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgcGF0aDogcCxcbiAgICAgICAgICBicmFuY2g6IHZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfUHJvcCRjaGVjayA9IFByb3AuY2hlY2sodiwgYiwgcCksXG4gICAgICAgICAgcGZzID0gX1Byb3AkY2hlY2tbMF0sXG4gICAgICAgICAgcHIgPSBfUHJvcCRjaGVja1sxXTtcblxuICAgICAgaWYgKHBmcykge1xuICAgICAgICBmYWlsdXJlcy5wdXNoLmFwcGx5KGZhaWx1cmVzLCBwZnMpO1xuICAgICAgfSBlbHNlIGlmIChwciAhPT0gdW5kZWZpbmVkICYmIGsgaW4gUHJvcHMpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhaWx1cmVzLmxlbmd0aCA/IFtmYWlsdXJlc10gOiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICB9O1xuXG4gIHJldHVybiBTdHJ1Y3Q7XG59O1xuXG52YXIgY3JlYXRlUGljayA9IGZ1bmN0aW9uIGNyZWF0ZVBpY2soc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KSB7XG4gIGludmFyaWFudCh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgXCJQaWNrIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcbiAgdmFyIFByb3BzID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgIFByb3BzW2tleV0gPSBzdHJ1Y3Qoc2NoZW1hW2tleV0pO1xuICB9XG5cbiAgdmFyIFN0cnVjdCA9IGNyZWF0ZVN0cnVjdCh7XG4gICAga2luZDogJ3BpY2snLFxuICAgIHR5cGU6IFwicGljazx7XCIgKyBPYmplY3Qua2V5cyhzY2hlbWEpLmpvaW4oKSArIFwifT5cIixcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgc3RydWN0OiBzdHJ1Y3RcbiAgfSk7XG5cbiAgU3RydWN0LmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlLCBicmFuY2gsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBTdHJ1Y3QuZGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciBkID0gU3RydWN0LmRlZmF1bHQoKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IGQ7XG4gICAgfVxuXG4gICAgaWYgKGtpbmRPZih2YWx1ZSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gW1tTdHJ1Y3QuZmFpbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgYnJhbmNoOiBicmFuY2gsXG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pXV07XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBmYWlsdXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgayBpbiBQcm9wcykge1xuICAgICAgdmFyIHYgPSB2YWx1ZVtrXTtcbiAgICAgIHZhciBwID0gcGF0aC5jb25jYXQoayk7XG4gICAgICB2YXIgYiA9IGJyYW5jaC5jb25jYXQodik7XG4gICAgICB2YXIgUHJvcCA9IFByb3BzW2tdO1xuXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkICYmIGQgIT0gbnVsbCAmJiBrIGluIGQpIHtcbiAgICAgICAgdiA9IHR5cGVvZiBkW2tdID09PSAnZnVuY3Rpb24nID8gZFtrXSh2YWx1ZSwgYnJhbmNoLCBwYXRoKSA6IGRba107XG4gICAgICB9XG5cbiAgICAgIHZhciBfUHJvcCRjaGVjayA9IFByb3AuY2hlY2sodiwgYiwgcCksXG4gICAgICAgICAgcGZzID0gX1Byb3AkY2hlY2tbMF0sXG4gICAgICAgICAgcHIgPSBfUHJvcCRjaGVja1sxXTtcblxuICAgICAgaWYgKHBmcykge1xuICAgICAgICBmYWlsdXJlcy5wdXNoLmFwcGx5KGZhaWx1cmVzLCBwZnMpO1xuICAgICAgfSBlbHNlIGlmIChwciAhPT0gdW5kZWZpbmVkICYmIGsgaW4gUHJvcHMpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhaWx1cmVzLmxlbmd0aCA/IFtmYWlsdXJlc10gOiBbdW5kZWZpbmVkLCByZXN1bHRdO1xuICB9O1xuXG4gIHJldHVybiBTdHJ1Y3Q7XG59O1xuXG52YXIgY3JlYXRlUmVjb3JkID0gZnVuY3Rpb24gY3JlYXRlUmVjb3JkKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzY2hlbWEpICYmIHNjaGVtYS5sZW5ndGggPT09IDIsIFwiUmVjb3JkIHN0cnVjdHMgbXVzdCBiZSBkZWZpbmVkIGFzIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzLCBidXQgeW91IHBhc3NlZDogXCIgKyBzY2hlbWEpO1xuICB2YXIgS2V5ID0gc3RydWN0KHNjaGVtYVswXSk7XG4gIHZhciBWYWx1ZSA9IHN0cnVjdChzY2hlbWFbMV0pO1xuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAncmVjb3JkJyxcbiAgICB0eXBlOiBcInJlY29yZDxcIiArIEtleS50eXBlICsgXCIsXCIgKyBWYWx1ZS50eXBlICsgXCI+XCIsXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIHN0cnVjdDogc3RydWN0XG4gIH0pO1xuXG4gIFN0cnVjdC5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYnJhbmNoLCBwYXRoKSB7XG4gICAgLy8gUmVjb3JkIHN0cnVjdHMgaGF2ZSBhIHNwZWNpYWwgZGVmYXVsdCBoYW5kbGluZyBiZWhhdmlvciwgd2hlcmUgdGhlIGRlZmF1bHRzXG4gICAgLy8gYXJlIGZvciB0aGUgZW50cmllcyB0aGVtc2VsdmVzLCBub3QgZm9yIHRoZSBlbnRpcmUgdmFsdWUuIFNvIHdlIGNhbid0IHVzZVxuICAgIC8vIEphdmFTY3JpcHQncyBidWlsdC1pbiBkZWZhdWx0IGhhbmRsaW5nIGhlcmUuXG4gICAgdmFyIGRlZnMgPSBTdHJ1Y3QuZGVmYXVsdCgpO1xuICAgIHZhbHVlID0gZGVmcyA/IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZzKSwgdmFsdWUpIDogdmFsdWU7XG5cbiAgICBpZiAoa2luZE9mKHZhbHVlKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBbW1N0cnVjdC5mYWlsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBicmFuY2g6IGJyYW5jaCxcbiAgICAgICAgcGF0aDogcGF0aFxuICAgICAgfSldXTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGZhaWx1cmVzID0gW107XG5cbiAgICBmb3IgKHZhciBrIGluIHZhbHVlKSB7XG4gICAgICB2YXIgdiA9IHZhbHVlW2tdO1xuICAgICAgdmFyIHAgPSBwYXRoLmNvbmNhdChrKTtcbiAgICAgIHZhciBiID0gYnJhbmNoLmNvbmNhdCh2KTtcblxuICAgICAgdmFyIF9LZXkkY2hlY2sgPSBLZXkuY2hlY2soaywgYiwgcCksXG4gICAgICAgICAga2ZzID0gX0tleSRjaGVja1swXSxcbiAgICAgICAgICBrciA9IF9LZXkkY2hlY2tbMV07XG5cbiAgICAgIGlmIChrZnMpIHtcbiAgICAgICAgZmFpbHVyZXMucHVzaC5hcHBseShmYWlsdXJlcywga2ZzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfVmFsdWUkY2hlY2sgPSBWYWx1ZS5jaGVjayh2LCBiLCBwKSxcbiAgICAgICAgICAgIHZmcyA9IF9WYWx1ZSRjaGVja1swXSxcbiAgICAgICAgICAgIHZyID0gX1ZhbHVlJGNoZWNrWzFdO1xuXG4gICAgICAgIGlmICh2ZnMpIHtcbiAgICAgICAgICBmYWlsdXJlcy5wdXNoLmFwcGx5KGZhaWx1cmVzLCB2ZnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrcl0gPSB2cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWlsdXJlcy5sZW5ndGggPyBbZmFpbHVyZXNdIDogW3VuZGVmaW5lZCwgcmVzdWx0XTtcbiAgfTtcblxuICByZXR1cm4gU3RydWN0O1xufTtcblxudmFyIGNyZWF0ZVNjYWxhciA9IGZ1bmN0aW9uIGNyZWF0ZVNjYWxhcihzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpIHtcbiAgaW52YXJpYW50KHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnLCBcIlNjYWxhciBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhIHN0cmluZywgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcbiAgdmFyIFR5cGVzID0gc3RydWN0LlR5cGVzO1xuICBpbnZhcmlhbnQoc2NoZW1hIGluIFR5cGVzLCBcIk5vIHN0cnVjdCB2YWxpZGF0b3IgZnVuY3Rpb24gZm91bmQgZm9yIHR5cGUgXFxcIlwiICsgc2NoZW1hICsgXCJcXFwiLlwiKTtcbiAgdmFyIFN0cnVjdCA9IHN0cnVjdChUeXBlc1tzY2hlbWFdLCBkZWZhdWx0cyk7XG4gIFN0cnVjdC5raW5kID0gJ3NjYWxhcic7XG4gIFN0cnVjdC50eXBlID0gc2NoZW1hO1xuICByZXR1cm4gU3RydWN0O1xufTtcblxudmFyIGNyZWF0ZVNob3J0aGFuZCA9IGZ1bmN0aW9uIGNyZWF0ZVNob3J0aGFuZChzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpIHtcbiAgaWYgKGlzU3RydWN0KHNjaGVtYSkpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGlmIChzY2hlbWEubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgX3NjaGVtYSA9IHNjaGVtYSxcbiAgICAgICAgICBmaXJzdCA9IF9zY2hlbWFbMF07XG4gICAgICByZXR1cm4gc3RydWN0LmFycmF5KFtmaXJzdF0sIGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gc3RydWN0LnR1cGxlKHNjaGVtYSwgZGVmYXVsdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0cnVjdC5mdW5jdGlvbihzY2hlbWEsIGRlZmF1bHRzKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzdHJ1Y3Qub2JqZWN0KHNjaGVtYSwgZGVmYXVsdHMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgdmFyIFN0cnVjdDtcblxuICAgIGlmIChzY2hlbWEuZW5kc1dpdGgoJz8nKSkge1xuICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLmluY2x1ZGVzKCd8JykpIHtcbiAgICAgIHZhciBzY2FsYXJzID0gc2NoZW1hLnNwbGl0KC9cXHMqXFx8XFxzKi9nKTtcbiAgICAgIFN0cnVjdCA9IHN0cnVjdC51bmlvbihzY2FsYXJzLCBkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEuaW5jbHVkZXMoJyYnKSkge1xuICAgICAgdmFyIF9zY2FsYXJzID0gc2NoZW1hLnNwbGl0KC9cXHMqJlxccyovZyk7XG5cbiAgICAgIFN0cnVjdCA9IHN0cnVjdC5pbnRlcnNlY3Rpb24oX3NjYWxhcnMsIGRlZmF1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgU3RydWN0ID0gc3RydWN0LnNjYWxhcihzY2hlbWEsIGRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgIFN0cnVjdCA9IHN0cnVjdC51bmlvbihbU3RydWN0LCAndW5kZWZpbmVkJ10sIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cnVjdDtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkEgc2NoZW1hIGRlZmluaXRpb24gbXVzdCBiZSBhbiBvYmplY3QsIGFycmF5LCBzdHJpbmcgb3IgZnVuY3Rpb24sIGJ1dCB5b3UgcGFzc2VkOiBcIiArIHNjaGVtYSk7XG59O1xuXG52YXIgY3JlYXRlVHVwbGUgPSBmdW5jdGlvbiBjcmVhdGVUdXBsZShzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpIHtcbiAgaW52YXJpYW50KEFycmF5LmlzQXJyYXkoc2NoZW1hKSwgXCJUdXBsZSBzdHJ1Y3RzIG11c3QgYmUgZGVmaW5lZCBhcyBhbiBhcnJheSwgYnV0IHlvdSBwYXNzZWQ6IFwiICsgc2NoZW1hKTtcbiAgdmFyIEVsZW1lbnRzID0gc2NoZW1hLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzdHJ1Y3Qocyk7XG4gIH0pO1xuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAndHVwbGUnLFxuICAgIHR5cGU6IFwiW1wiICsgRWxlbWVudHMubWFwKGZ1bmN0aW9uIChTKSB7XG4gICAgICByZXR1cm4gUy50eXBlO1xuICAgIH0pLmpvaW4oKSArIFwiXVwiLFxuICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICBzdHJ1Y3Q6IHN0cnVjdFxuICB9KTtcblxuICBTdHJ1Y3QuY2hlY2sgPSBmdW5jdGlvbiAodmFsdWUsIGJyYW5jaCwgcGF0aCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IFN0cnVjdC5kZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtbU3RydWN0LmZhaWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJyYW5jaDogYnJhbmNoLFxuICAgICAgICBwYXRoOiBwYXRoXG4gICAgICB9KV1dO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZmFpbHVyZXMgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgodmFsdWUubGVuZ3RoLCBFbGVtZW50cy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIEVsZW1lbnQgPSBFbGVtZW50c1tpXTtcbiAgICAgIHZhciB2ID0gdmFsdWVbaV07XG4gICAgICB2YXIgcCA9IHBhdGguY29uY2F0KGkpO1xuICAgICAgdmFyIGIgPSBicmFuY2guY29uY2F0KHYpO1xuXG4gICAgICBpZiAoIUVsZW1lbnQpIHtcbiAgICAgICAgZmFpbHVyZXMucHVzaChTdHJ1Y3QuZmFpbCh7XG4gICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgICAgYnJhbmNoOiBiXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfRWxlbWVudCRjaGVjayA9IEVsZW1lbnQuY2hlY2sodiwgYiwgcCksXG4gICAgICAgICAgICBlZnMgPSBfRWxlbWVudCRjaGVja1swXSxcbiAgICAgICAgICAgIGVyID0gX0VsZW1lbnQkY2hlY2tbMV07XG5cbiAgICAgICAgaWYgKGVmcykge1xuICAgICAgICAgIGZhaWx1cmVzLnB1c2guYXBwbHkoZmFpbHVyZXMsIGVmcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFpbHVyZXMubGVuZ3RoID8gW2ZhaWx1cmVzXSA6IFt1bmRlZmluZWQsIHJlc3VsdF07XG4gIH07XG5cbiAgcmV0dXJuIFN0cnVjdDtcbn07XG5cbnZhciBjcmVhdGVVbmlvbiA9IGZ1bmN0aW9uIGNyZWF0ZVVuaW9uKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCkge1xuICBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzY2hlbWEpICYmIHNjaGVtYS5sZW5ndGggIT09IDAsIFwiVW5pb24gc3RydWN0cyBtdXN0IGJlIGRlZmluZWQgYXMgYSBub24tZW1wdHkgYXJyYXksIGJ1dCB5b3UgcGFzc2VkOiBcIiArIHNjaGVtYSk7XG4gIHZhciBTdHJ1Y3RzID0gc2NoZW1hLm1hcChmdW5jdGlvbiAoc2NoKSB7XG4gICAgcmV0dXJuIHN0cnVjdChzY2gpO1xuICB9KTtcbiAgdmFyIHR5cGUgPSBTdHJ1Y3RzLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnR5cGU7XG4gIH0pLmpvaW4oJyB8ICcpO1xuICB2YXIgU3RydWN0ID0gY3JlYXRlU3RydWN0KHtcbiAgICBraW5kOiAndW5pb24nLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgIHN0cnVjdDogc3RydWN0XG4gIH0pO1xuXG4gIFN0cnVjdC5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSwgYnJhbmNoLCBwYXRoKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gU3RydWN0LmRlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKFN0cnVjdHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdHJ1Y3QgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFyIF9zdHJ1Y3QkY2hlY2sgPSBfc3RydWN0LmNoZWNrKHZhbHVlLCBicmFuY2gsIHBhdGgpLFxuICAgICAgICAgIGZzID0gX3N0cnVjdCRjaGVja1swXSxcbiAgICAgICAgICB2ID0gX3N0cnVjdCRjaGVja1sxXTtcblxuICAgICAgaWYgKCFmcykge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtbU3RydWN0LmZhaWwoe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnJhbmNoOiBicmFuY2gsXG4gICAgICBwYXRoOiBwYXRoXG4gICAgfSldXTtcbiAgfTtcblxuICByZXR1cm4gU3RydWN0O1xufTtcblxuLyoqXHJcbiAqIENyZWF0ZSBhIHN0cnVjdCBzaW5nbGV0b24gd2l0aCBzZXR0aW5ncyB0aGF0IGluY2x1ZGUgeW91ciBvd24gZG9tYWluLXNwZWNpZmljXHJcbiAqIGRhdGEgYHR5cGVzYCwgYW5kIGFuIG9wdGlvbmFsIGN1c3RvbSBgRXJyb3JgIGNsYXNzLlxyXG4gKi9cblxudmFyIHN1cGVyc3RydWN0ID0gZnVuY3Rpb24gc3VwZXJzdHJ1Y3Qoc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHtcbiAgICBzZXR0aW5ncyA9IHt9O1xuICB9XG5cbiAgdmFyIHN0cnVjdCA9IGZ1bmN0aW9uIHN0cnVjdChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNob3J0aGFuZChzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpO1xuICB9O1xuXG4gIHN0cnVjdC5hcnJheSA9IGZ1bmN0aW9uIChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5KHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LmR5bmFtaWMgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVEeW5hbWljKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LmVudW0gPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVFbnVtKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LmZ1bmN0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KTtcbiAgfTtcblxuICBzdHJ1Y3QuaW5zdGFuY2UgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVJbnN0YW5jZShzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpO1xuICB9O1xuXG4gIHN0cnVjdC5pbnRlcmZhY2UgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVJbnRlcmZhY2Uoc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KTtcbiAgfTtcblxuICBzdHJ1Y3QuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSwgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gY3JlYXRlSW50ZXJzZWN0aW9uKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LmxhenkgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVMYXp5KHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LmxpdGVyYWwgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVMaXRlcmFsKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0Lm9iamVjdCA9IGZ1bmN0aW9uIChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdChzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpO1xuICB9O1xuXG4gIHN0cnVjdC5vcHRpb25hbCA9IGZ1bmN0aW9uIChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVVuaW9uKFtzY2hlbWEsICd1bmRlZmluZWQnXSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LnBhcnRpYWwgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVQYXJ0aWFsKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LnBpY2sgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVQaWNrKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LnJlY29yZCA9IGZ1bmN0aW9uIChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlY29yZChzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpO1xuICB9O1xuXG4gIHN0cnVjdC5zY2FsYXIgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVTY2FsYXIoc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KTtcbiAgfTtcblxuICBzdHJ1Y3Quc2l6ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNpemUoc2NoZW1hLCBkZWZhdWx0cywgc3RydWN0KTtcbiAgfTtcblxuICBzdHJ1Y3QudHVwbGUgPSBmdW5jdGlvbiAoc2NoZW1hLCBkZWZhdWx0cykge1xuICAgIHJldHVybiBjcmVhdGVUdXBsZShzY2hlbWEsIGRlZmF1bHRzLCBzdHJ1Y3QpO1xuICB9O1xuXG4gIHN0cnVjdC51bmlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVVuaW9uKHNjaGVtYSwgZGVmYXVsdHMsIHN0cnVjdCk7XG4gIH07XG5cbiAgc3RydWN0LkVycm9yID0gc2V0dGluZ3MuZXJyb3IgfHwgU3RydWN0RXJyb3I7XG4gIHN0cnVjdC5UeXBlcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBUeXBlcyksIHNldHRpbmdzLnR5cGVzKTtcbiAgcmV0dXJuIHN0cnVjdDtcbn07XG5cbi8qKlxyXG4gKiBUaGUgc2luZ2xldG9uIGluc3RhbmNlIG9mIFN1cGVyc3RydWN0IHRoYXQgaXMgZXhwb3J0ZWQgYnkgZGVmYXVsdCwgY29uZmlndXJlZFxyXG4gKiB3aXRoIHR5cGVzIGZvciBhbGwgb2YgdGhlIEphdmFTY3JpcHQgYnVpbHQtaW4gZGF0YSB0eXBlcy5cclxuICpcclxuICogWW91IGNhbiB1c2UgaXQgaWYgeW91IGRvbid0IG5lZWQgYW55IGN1c3RvbSB0eXBlcy4gSG93ZXZlciwgaWYgeW91IGRvIHdhbnQgdG9cclxuICogZGVmaW5lIGN1c3RvbSB0eXBlcywgdXNlIHRoZSBbW3N1cGVyc3RydWN0XV0gZmFjdG9yeSB0byBjb25maWd1cmUgeW91ciBvd25cclxuICogW1tTdXBlcnN0cnVjdF1dIGluc3RhbmNlLlxyXG4gKi9cblxudmFyIHN0cnVjdCA9IHN1cGVyc3RydWN0KCk7XG5cbmV4cG9ydHMuU3RydWN0RXJyb3IgPSBTdHJ1Y3RFcnJvcjtcbmV4cG9ydHMuVHlwZXMgPSBUeXBlcztcbmV4cG9ydHMuaXNTdHJ1Y3QgPSBpc1N0cnVjdDtcbmV4cG9ydHMuc3RydWN0ID0gc3RydWN0O1xuZXhwb3J0cy5zdXBlcnN0cnVjdCA9IHN1cGVyc3RydWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgZGVmYXVsdEhlYWRlcnMgfSBmcm9tICcuLi91dGlscy9odHRwJ1xuaW1wb3J0IHsgc3RydWN0LCBtaW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sIG1pbkFQSVBhcmFtZXRlclZhbGlkYXRvciB9IGZyb20gJy4uL3V0aWxzL3ZhbGlkYXRvcidcblxuY29uc3QgbG9nID0gZGVidWcoJ3N0YXJsaW5nOmFjY291bnQtc2VydmljZScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGEgY3VzdG9tZXIncyBhY2NvdW50XG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgYWNjb3VudCBjbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhcHBsaWNhdGlvbiBjb25maWdcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhY2NvdW50IGhvbGRlcidzIGJhbmsgYWNjb3VudHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRBY2NvdW50cyAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9hY2NvdW50c2BcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhY2NvdW50J3MgYmFuayBpZGVudGlmaWVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjb3VudFVpZCAtIHRoZSBhY2NvdW50IHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0QWNjb3VudElkZW50aWZpZXJzIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRBY2NvdW50SWRlbnRpZmllcnNQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnRzLyR7YWNjb3VudFVpZH0vaWRlbnRpZmllcnNgXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYWNjb3VudCdzIGJhbGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY291bnRVaWQgLSB0aGUgYWNjb3VudCB1aWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldEFjY291bnRCYWxhbmNlIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRBY2NvdW50QmFsYW5jZVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiwgYWNjb3VudFVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudHMvJHthY2NvdW50VWlkfS9iYWxhbmNlYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlcmUgYXJlIGF2YWlsYWJsZSBmdW5kcyBmb3IgYSByZXF1ZXN0ZWQgYW1vdW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbWV0ZXJzLnRhcmdldEFtb3VudEluTWlub3JVbml0cyAtIHRoZSB0YXJnZXQgYW1vdW50IGluIG1pbm9yIHVuaXRzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRDb25maXJtYXRpb25PZkZ1bmRzIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRDb25maXJtYXRpb25PZkZ1bmRzUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBhY2NvdW50VWlkLCB0YXJnZXRBbW91bnRJbk1pbm9yVW5pdHMgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnRzLyR7YWNjb3VudFVpZH0vY29uZmlybWF0aW9uLW9mLWZ1bmRzYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB0YXJnZXRBbW91bnRJbk1pbm9yVW5pdHNcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBsaXN0IG9mIHN0YXRlbWVudCBwZXJpb2RzIHdoaWNoIGFyZSBhdmFpbGFibGUgZm9yIGFuIGFjY291bnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY291bnRVaWQgLSB0aGUgYWNjb3VudCB1aWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldFN0YXRlbWVudFBlcmlvZHMgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGdldFN0YXRlbWVudFBlcmlvZHNQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnRzLyR7YWNjb3VudFVpZH0vc3RhdGVtZW50L2F2YWlsYWJsZS1wZXJpb2RzYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRG93bmxvYWQgYSBzdGF0ZW1lbnQgZm9yIGEgZ2l2ZW4gc3RhdGVtZW50IHBlcmlvZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjb3VudFVpZCAtIHRoZSBhY2NvdW50IHVpZFxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhcmFtZXRlcnMueWVhck1vbnRoIC0gdGhlIHN0YXRlbWVudCBwZXJpb2QncyB5ZWFyIG1vbnRoICh5eXl5LU1NKVxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhcmFtZXRlcnMuZm9ybWF0IC0gb25lIG9mICdhcHBsaWNhdGlvbi9wZGYnIG9yICd0ZXh0L2NzdidcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXJhbWV0ZXJzLnJlc3BvbnNlVHlwZSAtIHRoZSBheGlvcyByZXNwb25zZVR5cGUgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRTdGF0ZW1lbnRGb3JQZXJpb2QgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgeyB5ZWFyTW9udGg6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KSwgZm9ybWF0OiAndGV4dC9jc3YnLCByZXNwb25zZVR5cGU6ICdzdHJlYW0nIH0sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRTdGF0ZW1lbnRGb3JQZXJpb2RQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIGZvcm1hdCwgeWVhck1vbnRoLCByZXNwb25zZVR5cGUgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnRzLyR7YWNjb3VudFVpZH0vc3RhdGVtZW50L2Rvd25sb2FkYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pLFxuICAgICAgICBBY2NlcHQ6IGZvcm1hdFxuICAgICAgfSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB5ZWFyTW9udGhcbiAgICAgIH0sXG4gICAgICByZXNwb25zZVR5cGVcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkIGEgc3RhdGVtZW50IGZvciBhIGdpdmVuIGRhdGUgcmFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY291bnRVaWQgLSB0aGUgYWNjb3VudCB1aWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuc3RhcnQgLSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdGF0ZW1lbnQgZGF0ZSByYW5nZSAoeXl5eS1NTS1kZClcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXJhbWV0ZXJzLmVuZCAtIHRoZSBlbmQgb2YgdGhlIHN0YXRlbWVudCBkYXRlIHJhbmdlICh5eXl5LU1NLWRkKVxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhcmFtZXRlcnMuZm9ybWF0IC0gb25lIG9mICdhcHBsaWNhdGlvbi9wZGYnIG9yICd0ZXh0L2NzdidcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXJhbWV0ZXJzLnJlc3BvbnNlVHlwZSAtIHRoZSBheGlvcyByZXNwb25zZVR5cGUgZm9yIHRoZSByZXF1ZXN0XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRTdGF0ZW1lbnRGb3JSYW5nZSAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB7IGZvcm1hdDogJ3RleHQvY3N2JywgcmVzcG9uc2VUeXBlOiAnc3RyZWFtJyB9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgZ2V0U3RhdGVtZW50Rm9yUmFuZ2VQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIHN0YXJ0LCBlbmQsIGZvcm1hdCwgcmVzcG9uc2VUeXBlIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9hY2NvdW50cy8ke2FjY291bnRVaWR9L3N0YXRlbWVudC9kb3dubG9hZEZvckRhdGVSYW5nZWBcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLmRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKSxcbiAgICAgICAgQWNjZXB0OiBmb3JtYXRcbiAgICAgIH0sXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlVHlwZVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgZ2V0QWNjb3VudElkZW50aWZpZXJzUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7IC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbiwgYWNjb3VudFVpZDogJ3V1aWQnIH0pXG5cbmNvbnN0IGdldEFjY291bnRCYWxhbmNlUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7IC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbiwgYWNjb3VudFVpZDogJ3V1aWQnIH0pXG5cbmNvbnN0IGdldENvbmZpcm1hdGlvbk9mRnVuZHNQYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKHsgLi4ubWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLCBhY2NvdW50VWlkOiAndXVpZCcsIHRhcmdldEFtb3VudEluTWlub3JVbml0czogJ251bWJlcicgfSlcblxuY29uc3QgZ2V0U3RhdGVtZW50UGVyaW9kc1BhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2UoeyAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sIGFjY291bnRVaWQ6ICd1dWlkJyB9KVxuXG5jb25zdCBnZXRTdGF0ZW1lbnRGb3JQZXJpb2RQYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKHtcbiAgLi4ubWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLFxuICBhY2NvdW50VWlkOiAndXVpZCcsXG4gIHllYXJNb250aDogJ3llYXJNb250aCcsXG4gIGZvcm1hdDogc3RydWN0LmVudW0oWydhcHBsaWNhdGlvbi9wZGYnLCAndGV4dC9jc3YnXSksXG4gIHJlc3BvbnNlVHlwZTogJ3N0cmluZydcbn0pXG5cbmNvbnN0IGdldFN0YXRlbWVudEZvclJhbmdlUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgYWNjb3VudFVpZDogJ3V1aWQnLFxuICBzdGFydDogJ2RhdGUnLFxuICBlbmQ6ICdkYXRlPycsXG4gIGZvcm1hdDogc3RydWN0LmVudW0oWydhcHBsaWNhdGlvbi9wZGYnLCAndGV4dC9jc3YnXSksXG4gIHJlc3BvbnNlVHlwZTogJ3N0cmluZydcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gQWNjb3VudFxuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgZGVmYXVsdEhlYWRlcnMgfSBmcm9tICcuLi91dGlscy9odHRwJ1xuaW1wb3J0IHsgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vdXRpbHMvdmFsaWRhdG9yJ1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnc3Rhcmxpbmc6YWNjb3VudC1ob2xkZXItc2VydmljZScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGFuIGFjY291bnQgaG9sZGVyXG4gKi9cbmNsYXNzIEFjY291bnRIb2xkZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgYWNjb3VudCBob2xkZXIgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYXBwbGljYXRpb24gY29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYmFzaWMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjY291bnQgaG9sZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0QWNjb3VudEhvbGRlciAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9hY2NvdW50LWhvbGRlcmBcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgYWNjb3VudCBob2xkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRBY2NvdW50SG9sZGVyTmFtZSAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9hY2NvdW50LWhvbGRlci9uYW1lYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluZGl2aWR1YWwgYWNjb3VudCBob2xkZXIncyBkZXRhaWxzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0QWNjb3VudEhvbGRlckluZGl2aWR1YWwgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIG1pbkFQSVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudC1ob2xkZXIvaW5kaXZpZHVhbGBcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGpvaW50IGFjY291bnQgaG9sZGVyJ3MgZGV0YWlsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldEFjY291bnRIb2xkZXJKb2ludCAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9hY2NvdW50LWhvbGRlci9qb2ludGBcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1c2luZXNzIGFjY291bnQgaG9sZGVyJ3MgZGV0YWlsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldEFjY291bnRIb2xkZXJCdXNpbmVzcyAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9hY2NvdW50LWhvbGRlci9idXNpbmVzc2BcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1c2luZXNzIGFjY291bnQgaG9sZGVyJ3MgcmVnaXN0ZXJlZCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0QWNjb3VudEhvbGRlckJ1c2luZXNzUmVnaXN0ZXJlZEFkZHJlc3MgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIG1pbkFQSVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudC1ob2xkZXIvYnVzaW5lc3MvcmVnaXN0ZXJlZC1hZGRyZXNzYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYnVzaW5lc3MgYWNjb3VudCBob2xkZXIncyBjb3JyZXNwb25kZW5jZSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0QWNjb3VudEhvbGRlckJ1c2luZXNzQ29ycmVzcG9uZGVuY2VBZGRyZXNzIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4gfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnQtaG9sZGVyL2J1c2luZXNzL2NvcnJlc3BvbmRlbmNlLWFkZHJlc3NgXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY291bnRIb2xkZXJcbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCB7IGRlZmF1bHRIZWFkZXJzIH0gZnJvbSAnLi4vdXRpbHMvaHR0cCdcbmltcG9ydCB7IG1pbkFQSVBhcmFtZXRlclZhbGlkYXRvciB9IGZyb20gJy4uL3V0aWxzL3ZhbGlkYXRvcidcblxuY29uc3QgbG9nID0gZGVidWcoJ3N0YXJsaW5nOmFkZHJlc3Mtc2VydmljZScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGEgY3VzdG9tZXIgYWRkcmVzc1xuICovXG5jbGFzcyBBZGRyZXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGFkZHJlc3MgY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBjdXN0b21lcidzIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0QWRkcmVzc2VzIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4gfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FkZHJlc3Nlc2BcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkcmVzc1xuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgZGVmYXVsdEhlYWRlcnMsIHBheWxvYWRIZWFkZXJzIH0gZnJvbSAnLi4vdXRpbHMvaHR0cCdcbmltcG9ydCB7IHN0cnVjdCwgbWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLCBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IgfSBmcm9tICcuLi91dGlscy92YWxpZGF0b3InXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdzdGFybGluZzpjYXJkLXNlcnZpY2UnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaW50ZXJhY3Qgd2l0aCBhIGN1c3RvbWVyIGNhcmRcbiAqL1xuY2xhc3MgQ2FyZCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBjbGllbnQncyBjYXJkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBjYXJkcyBmb3IgYW4gYWNjb3VudCBob2xkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRDYXJkcyAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9jYXJkc2BcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjYXJkIGxvY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmNhcmRVaWQgLSB0aGUgY2FyZCB1aWRcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbWV0ZXJzLmVuYWJsZWQgLSBXaGV0aGVyIHRoZSBjYXJkIHNob3VsZCBiZSBsb2NrZWQuIFNldCB0byBmYWxzZSB0byBsb2NrLCB0cnVlIHRvIHVubG9jay5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHVwZGF0ZUNhcmRMb2NrIChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlQ2FyZENvbnRyb2woeyAuLi5wYXJhbWV0ZXJzLCBlbmRwb2ludDogJ2VuYWJsZWQnIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIEFUTSB3aXRoZHJhd2FsIGNvbnRyb2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmNhcmRVaWQgLSB0aGUgY2FyZCB1aWRcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbWV0ZXJzLmVuYWJsZWQgLSBXaGV0aGVyIEFUTSB3aXRoZHJhd2FscyBzaG91bGQgYmUgYWxsb3dlZC4gU2V0IHRvIGZhbHNlIHRvIGJsb2NrLCB0cnVlIHRvIGFsbG93LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgdXBkYXRlQ2FyZEFUTUNvbnRyb2wgKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVDYXJkQ29udHJvbCh7IC4uLnBhcmFtZXRlcnMsIGVuZHBvaW50OiAnYXRtLWVuYWJsZWQnIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG9ubGluZSBwYXltZW50cyBjb250cm9sXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jYXJkVWlkIC0gdGhlIGNhcmQgdWlkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1ldGVycy5lbmFibGVkIC0gV2hldGhlciBvbmxpbmUgcGF5bWVudHMgc2hvdWxkIGJlIGFsbG93ZWQuIFNldCB0byBmYWxzZSB0byBibG9jaywgdHJ1ZSB0byBhbGxvdy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHVwZGF0ZUNhcmRPbmxpbmVDb250cm9sIChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlQ2FyZENvbnRyb2woeyAuLi5wYXJhbWV0ZXJzLCBlbmRwb2ludDogJ29ubGluZS1lbmFibGVkJyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBtb2JpbGUgd2FsbGV0IHBheW1lbnRzIGNvbnRyb2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmNhcmRVaWQgLSB0aGUgY2FyZCB1aWRcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbWV0ZXJzLmVuYWJsZWQgLSBXaGV0aGVyIG1vYmlsZSB3YWxsZXQgcGF5bWVudHMgc2hvdWxkIGJlIGFsbG93ZWQuIFNldCB0byBmYWxzZSB0byBibG9jaywgdHJ1ZSB0byBhbGxvdy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHVwZGF0ZUNhcmRNb2JpbGVXYWxsZXRDb250cm9sIChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlQ2FyZENvbnRyb2woeyAuLi5wYXJhbWV0ZXJzLCBlbmRwb2ludDogJ21vYmlsZS13YWxsZXQtZW5hYmxlZCcgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZ2FtYmxpbmcgcGF5bWVudHMgY29udHJvbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuY2FyZFVpZCAtIHRoZSBjYXJkIHVpZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtZXRlcnMuZW5hYmxlZCAtIFdoZXRoZXIgZ2FtYmxpbmcgcGF5bWVudHMgc2hvdWxkIGJlIGFsbG93ZWQuIFNldCB0byBmYWxzZSB0byBibG9jaywgdHJ1ZSB0byBhbGxvdy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHVwZGF0ZUNhcmRHYW1ibGluZ0NvbnRyb2wgKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVDYXJkQ29udHJvbCh7IC4uLnBhcmFtZXRlcnMsIGVuZHBvaW50OiAnZ2FtYmxpbmctZW5hYmxlZCcgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgY2FyZCBwcmVzZW50IHBheW1lbnRzIChjb250YWN0bGVzcyBhbmQgY2hpcCBhbmQgcGluKSBjb250cm9sXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jYXJkVWlkIC0gdGhlIGNhcmQgdWlkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1ldGVycy5lbmFibGVkIC0gV2hldGhlciBjYXJkIHByZXNlbnQgcGF5bWVudHMgKGNvbnRhY3RsZXNzIGFuZCBjaGlwIGFuZCBwaW4pIHNob3VsZCBiZSBhbGxvd2VkLiBTZXQgdG8gZmFsc2UgdG8gYmxvY2ssIHRydWUgdG8gYWxsb3cuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICB1cGRhdGVDYXJkUHJlc2VudENvbnRyb2wgKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVDYXJkQ29udHJvbCh7IC4uLnBhcmFtZXRlcnMsIGVuZHBvaW50OiAncG9zLWVuYWJsZWQnIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG1hZ3N0cmlwZSBwYXltZW50cyBjb250cm9sXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jYXJkVWlkIC0gdGhlIGNhcmQgdWlkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1ldGVycy5lbmFibGVkIC0gV2hldGhlciBtYWdzdHJpcGUgcGF5bWVudHMgc2hvdWxkIGJlIGFsbG93ZWQuIFNldCB0byBmYWxzZSB0byBibG9jaywgdHJ1ZSB0byBhbGxvdy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHVwZGF0ZUNhcmRNYWdzdHJpcGVDb250cm9sIChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlQ2FyZENvbnRyb2woeyAuLi5wYXJhbWV0ZXJzLCBlbmRwb2ludDogJ21hZy1zdHJpcGUtZW5hYmxlZCcgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjYXJkIGNvbnRyb2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmNhcmRVaWQgLSB0aGUgY2FyZCB1aWRcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbWV0ZXJzLmVuYWJsZWQgLSBXaGV0aGVyIHRoZSBjb250cm9sIHNob3VsZCBiZSBzaG91bGQgYmUgbG9ja2VkLiBTZXQgdG8gZmFsc2UgdG8gbG9jaywgdHJ1ZSB0byB1bmxvY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmVuZHBvaW50IC0gdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZW5kcG9pbnQgbmFtZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgdXBkYXRlQ2FyZENvbnRyb2wgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIHVwZGF0ZUNhcmRDb250cm9sUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBjYXJkVWlkLCBlbmFibGVkLCBlbmRwb2ludCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvY2FyZHMvJHtjYXJkVWlkfS9jb250cm9scy8ke2VuZHBvaW50fWBcbiAgICBsb2coYFBVVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBwYXlsb2FkSGVhZGVycyhhY2Nlc3NUb2tlbiksXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh7IGVuYWJsZWQgfSlcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IHVwZGF0ZUNhcmRDb250cm9sUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgY2FyZFVpZDogJ3V1aWQnLFxuICBlbmFibGVkOiAnYm9vbGVhbidcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FyZFxuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgZGVmYXVsdEhlYWRlcnMgfSBmcm9tICcuLi91dGlscy9odHRwJ1xuaW1wb3J0IHsgc3RydWN0LCBtaW5BUElQYXJhbWV0ZXJEZWZpbnRpb24gfSBmcm9tICcuLi91dGlscy92YWxpZGF0b3InXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdzdGFybGluZzpmZWVkLWl0ZW0tc2VydmljZScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGEgY3VzdG9tZXIncyBmZWVkIGl0ZW1zXG4gKi9cbmNsYXNzIEZlZWRJdGVtIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBmZWVkIGl0ZW0gc2VydmljZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogR2V0IGZlZWQgaXRlbXMgY3JlYXRlZCBiZXR3ZWVuIHR3byB0aW1lc3RhbXBzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmNhdGVnb3J5VWlkIC0gdGhlIGNhdGVnb3J5IHVpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5taW5UcmFuc2FjdGlvblRpbWVzdGFtcCAtIHRpbWVzdGFtcCBlLmcuICcyMDE5LTEwLTI1VDEyOjM0OjU2Ljc4OVonXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLm1heFRyYW5zYWN0aW9uVGltZXN0YW1wIC0gdGltZXN0YW1wIGUuZy4gJzIwMTktMTAtMjZUMTI6MzQ6NTYuNzg5WidcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldEZlZWRJdGVtc0JldHdlZW4gKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGdldEZlZWRJdGVtc0JldHdlZW5QYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIGNhdGVnb3J5VWlkLCBtaW5UcmFuc2FjdGlvblRpbWVzdGFtcCwgbWF4VHJhbnNhY3Rpb25UaW1lc3RhbXAgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2ZlZWQvYWNjb3VudC8ke2FjY291bnRVaWR9L2NhdGVnb3J5LyR7Y2F0ZWdvcnlVaWR9L3RyYW5zYWN0aW9ucy1iZXR3ZWVuYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5UcmFuc2FjdGlvblRpbWVzdGFtcCxcbiAgICAgICAgbWF4VHJhbnNhY3Rpb25UaW1lc3RhbXBcbiAgICAgIH0sXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGZlZWQgaXRlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjb3VudFVpZCAtIHRoZSBhY2NvdW50IHVpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jYXRlZ29yeVVpZCAtIHRoZSBjYXRlZ29yeSB1aWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuZmVlZEl0ZW1VaWQgLSB0aGUgZmVlZCBpdGVtIHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0RmVlZEl0ZW0gKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGdldEZlZWRJdGVtUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBhY2NvdW50VWlkLCBjYXRlZ29yeVVpZCwgZmVlZEl0ZW1VaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2ZlZWQvYWNjb3VudC8ke2FjY291bnRVaWR9L2NhdGVnb3J5LyR7Y2F0ZWdvcnlVaWR9LyR7ZmVlZEl0ZW1VaWR9YFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGZlZWQgaXRlbXMgY3JlYXRlZCBvciB1cGRhdGVkIHNpbmNlIGEgZ2l2ZW4gdGltZXN0YW1wXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmNhdGVnb3J5VWlkIC0gdGhlIGNhdGVnb3J5IHVpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jaGFuZ2VzU2luY2UgLSB0aW1lc3RhbXAgZS5nLiAnMjAxOS0xMC0yNVQxMjozNDo1Ni43ODlaJ1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0RmVlZEl0ZW1zQ2hhbmdlZFNpbmNlIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRGZWVkSXRlbXNDaGFuZ2VkU2luY2VQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIGNhdGVnb3J5VWlkLCBjaGFuZ2VzU2luY2UgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2ZlZWQvYWNjb3VudC8ke2FjY291bnRVaWR9L2NhdGVnb3J5LyR7Y2F0ZWdvcnlVaWR9YFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjaGFuZ2VzU2luY2VcbiAgICAgIH0sXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGdldEZlZWRJdGVtc0JldHdlZW5QYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKHtcbiAgLi4ubWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLFxuICBhY2NvdW50VWlkOiAndXVpZCcsXG4gIGNhdGVnb3J5VWlkOiAndXVpZCcsXG4gIG1pblRyYW5zYWN0aW9uVGltZXN0YW1wOiAndGltZXN0YW1wJyxcbiAgbWF4VHJhbnNhY3Rpb25UaW1lc3RhbXA6ICd0aW1lc3RhbXAnXG59KVxuXG5jb25zdCBnZXRGZWVkSXRlbVBhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sXG4gIGFjY291bnRVaWQ6ICd1dWlkJyxcbiAgY2F0ZWdvcnlVaWQ6ICd1dWlkJyxcbiAgZmVlZEl0ZW1VaWQ6ICd1dWlkJ1xufSlcblxuY29uc3QgZ2V0RmVlZEl0ZW1zQ2hhbmdlZFNpbmNlUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgYWNjb3VudFVpZDogJ3V1aWQnLFxuICBjYXRlZ29yeVVpZDogJ3V1aWQnLFxuICBjaGFuZ2VzU2luY2U6ICd0aW1lc3RhbXAnXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZlZWRJdGVtXG4iLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnXG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnXG5pbXBvcnQgeyBkZWZhdWx0SGVhZGVycyB9IGZyb20gJy4uL3V0aWxzL2h0dHAnXG5pbXBvcnQgeyBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IgfSBmcm9tICcuLi91dGlscy92YWxpZGF0b3InXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdzdGFybGluZzppZGVudGl0eS1zZXJ2aWNlJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGludGVyYWN0IHdpdGggdGhlIEFQSSBVc2VyIGlkZW50aXRpZXMgZW5kcG9pbnRzXG4gKi9cbmNsYXNzIElkZW50aXR5IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGlkZW50aXR5IGNsaWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHRva2VuIGlkZW50aXR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlbi5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldFRva2VuSWRlbnRpdHkgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIG1pbkFQSVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvaWRlbnRpdHkvdG9rZW5gXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGF1dGhvcmlzaW5nIGluZGl2aWR1YWwncyBpZGVudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW4uXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBnZXRBdXRob3Jpc2luZ0luZGl2aWR1YWwgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIG1pbkFQSVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvaWRlbnRpdHkvaW5kaXZpZHVhbGBcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSWRlbnRpdHlcbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCB7IGRlZmF1bHRIZWFkZXJzIH0gZnJvbSAnLi4vdXRpbHMvaHR0cCdcbmltcG9ydCB7IHN0cnVjdCwgbWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLCBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IgfSBmcm9tICcuLi91dGlscy92YWxpZGF0b3InXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdzdGFybGluZzptYW5kYXRlLXNlcnZpY2UnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaW50ZXJhY3Qgd2l0aCBhIGN1c3RvbWVyJ3MgbWFuZGF0ZXNcbiAqL1xuY2xhc3MgTWFuZGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWFuZGF0ZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgbGlzdCBvZiB0aGUgY3VzdG9tZXIncyBjdXJyZW50IGRpcmVjdCBkZWJpdCBtYW5kYXRlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGxpc3RNYW5kYXRlcyAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuIH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9kaXJlY3QtZGViaXQvbWFuZGF0ZXNgXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgc3BlY2lmaWMgZGlyZWN0IGRlYml0IG1hbmRhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLm1hbmRhdGVVaWQgLSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgbWFuZGF0ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0TWFuZGF0ZSAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgZ2V0TWFuZGF0ZVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiwgbWFuZGF0ZVVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvZGlyZWN0LWRlYml0L21hbmRhdGVzLyR7bWFuZGF0ZVVpZH1gXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHNwZWNpZmljIGRpcmVjdCBkZWJpdCBtYW5kYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMubWFuZGF0ZVVpZCAtIHRoZSB1bmlxdWUgbWFuZGF0ZSBJRFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZGVsZXRlTWFuZGF0ZSAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgZGVsZXRlTWFuZGF0ZVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiwgbWFuZGF0ZVVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvZGlyZWN0LWRlYml0L21hbmRhdGVzLyR7bWFuZGF0ZVVpZH1gXG4gICAgbG9nKGBERUxFVEUgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBnZXRNYW5kYXRlUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgbWFuZGF0ZVVpZDogJ3V1aWQnXG59KVxuXG5jb25zdCBkZWxldGVNYW5kYXRlUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgbWFuZGF0ZVVpZDogJ3V1aWQnXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmRhdGVcbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCB7IHN0cnVjdCB9IGZyb20gJy4uL3V0aWxzL3ZhbGlkYXRvcidcblxuY29uc3QgQUNDRVNTX1RPS0VOX0dSQU5UX1RZUEUgPSAnYXV0aG9yaXphdGlvbl9jb2RlJ1xuY29uc3QgUkVGUkVTSF9UT0tFTl9HUkFOVF9UWVBFID0gJ3JlZnJlc2hfdG9rZW4nXG5cbmNvbnN0IGxvZyA9IGRlYnVnKCdzdGFybGluZzpvYXV0aC1zZXJ2aWNlJylcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIGludGVyYWN0IHdpdGggYSB0aGUgb2F1dGggZW5kcG9pbnRcbiAqL1xuY2xhc3MgT0F1dGgge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9hdXRoIHNlcnZpY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEV4Y2hhbmdlcyB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIGZvciBhbiBhY2Nlc3MgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhvcml6YXRpb25Db2RlIC0gdGhlIGF1dGhvcml6YXRpb24gY29kZSwgYWNxdWlyZWQgZnJvbSB0aGUgdXNlciBhZ2VudCBhZnRlciB0aGUgdXNlciBhdXRoZW50aWNhdGVzIHdpdGggc3RhcmxpbmdcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldEFjY2Vzc1Rva2VuIChhdXRob3JpemF0aW9uQ29kZSkge1xuICAgIHJldHVybiB0aGlzLmdldE9BdXRoVG9rZW4oe1xuICAgICAgcXVlcnlQYXJhbXM6IHtcbiAgICAgICAgY29kZTogYXV0aG9yaXphdGlvbkNvZGUsXG4gICAgICAgIGdyYW50X3R5cGU6IEFDQ0VTU19UT0tFTl9HUkFOVF9UWVBFLFxuICAgICAgICBjbGllbnRfaWQ6IHRoaXMub3B0aW9ucy5jbGllbnRJZCxcbiAgICAgICAgY2xpZW50X3NlY3JldDogdGhpcy5vcHRpb25zLmNsaWVudFNlY3JldCxcbiAgICAgICAgcmVkaXJlY3RfdXJpOiB0aGlzLm9wdGlvbnMucmVkaXJlY3RVcmlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEV4Y2hhbmdlcyB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIGZvciBhbiBhY2Nlc3MgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZnJlc2hUb2tlbiAtIHRoZSBvYXV0aCByZWZyZXNoIHRva2VuLCB1c2VkIHdoZW4gdGhlIGFjY2VzcyB0b2tlbiBleHBpcmVzIHRvIGNsYWltIGEgbmV3IGFjY2VzcyB0b2tlbi5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHJlZnJlc2hBY2Nlc3NUb2tlbiAocmVmcmVzaFRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T0F1dGhUb2tlbih7XG4gICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgIGdyYW50X3R5cGU6IFJFRlJFU0hfVE9LRU5fR1JBTlRfVFlQRSxcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLm9wdGlvbnMuY2xpZW50SWQsXG4gICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMub3B0aW9ucy5jbGllbnRTZWNyZXRcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSBzdGFybGluZyBPQXV0aCBlbmRwb2ludFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgT0F1dGggdXJsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbWV0ZXJzLnF1ZXJ5UGFyYW1zIC0gdGhlIHF1ZXJ5IHBhcmFtcyBwYXNzZWQgdG8gdGhlIE9BdXRoIGVuZHBvaW50IGFzIHBlciB0aGUgT0F1dGggc3BlY1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0T0F1dGhUb2tlbiAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgZ2V0T0F1dGhUb2tlblBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBxdWVyeVBhcmFtcyB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9vYXV0aC9hY2Nlc3MtdG9rZW5gXG4gICAgbG9nKGBQT1NUICR7dXJsfSBxdWVyeVBhcmFtczoke0pTT04uc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zKX1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIHVybCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgcGFyYW1zOiBxdWVyeVBhcmFtc1xuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgZ2V0T0F1dGhUb2tlblBhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICBhcGlVcmw6ICdzdHJpbmcnLFxuICBxdWVyeVBhcmFtczogc3RydWN0LnVuaW9uKFtcbiAgICBzdHJ1Y3Qub2JqZWN0KHtcbiAgICAgIGNsaWVudF9pZDogJ3N0cmluZycsXG4gICAgICBjbGllbnRfc2VjcmV0OiAnc3RyaW5nJyxcbiAgICAgIGdyYW50X3R5cGU6IHN0cnVjdC5saXRlcmFsKEFDQ0VTU19UT0tFTl9HUkFOVF9UWVBFKSxcbiAgICAgIGNvZGU6ICdzdHJpbmcnLFxuICAgICAgcmVkaXJlY3RfdXJpOiAnc3RyaW5nJ1xuICAgIH0pLFxuICAgIHN0cnVjdC5vYmplY3Qoe1xuICAgICAgY2xpZW50X2lkOiAnc3RyaW5nJyxcbiAgICAgIGNsaWVudF9zZWNyZXQ6ICdzdHJpbmcnLFxuICAgICAgZ3JhbnRfdHlwZTogc3RydWN0LmxpdGVyYWwoUkVGUkVTSF9UT0tFTl9HUkFOVF9UWVBFKSxcbiAgICAgIHJlZnJlc2hfdG9rZW46ICdzdHJpbmcnXG4gICAgfSlcbiAgXSlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gT0F1dGhcbiIsImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCB7IGRlZmF1bHRIZWFkZXJzLCBwYXlsb2FkSGVhZGVycyB9IGZyb20gJy4uL3V0aWxzL2h0dHAnXG5pbXBvcnQgeyBzdHJ1Y3QsIG1pbkFQSVBhcmFtZXRlckRlZmludGlvbiwgbWluQVBJUGFyYW1ldGVyVmFsaWRhdG9yIH0gZnJvbSAnLi4vdXRpbHMvdmFsaWRhdG9yJ1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnc3Rhcmxpbmc6cGF5ZWUtc2VydmljZScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGFuIGFjY291bnQgaG9sZGVyJ3MgcGF5ZWVzXG4gKi9cbmNsYXNzIFBheWVlIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYXllZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYWNjb3VudCBob2xkZXIncyBwYXllZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0UGF5ZWVzIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4gfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL3BheWVlc2BcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYXllZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzLnBheWVlQ3JlYXRpb25SZXF1ZXN0IC0gdGhlIHBheWVlIGNyZWF0aW9uIHJlcXVlc3QuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gdGhlIGh0dHAgcmVxdWVzdCBwcm9taXNlXG4gICAqL1xuICBjcmVhdGVQYXllZSAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgY3JlYXRlUGF5ZWVQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIHBheWVlQ3JlYXRpb25SZXF1ZXN0IH0gPSBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB1cmwgPSBgJHthcGlVcmx9L2FwaS92Mi9wYXllZXNgXG4gICAgbG9nKGBQVVQgJHt1cmx9YClcbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IHBheWxvYWRIZWFkZXJzKGFjY2Vzc1Rva2VuKSxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHBheWVlQ3JlYXRpb25SZXF1ZXN0KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFuIGFjY291bnQgaG9sZGVyJ3MgcGF5ZWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5wYXllZVVpZCAtIHRoZSBwYXllZVVpZCBvZiB0aGUgcGF5ZWUgdG8gYmUgZGVsZXRlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGRlbGV0ZVBheWVlIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBkZWxldGVQYXllZVBhcmFtZXRlclZhbGlkYXRvcihwYXJhbWV0ZXJzKVxuICAgIGNvbnN0IHsgYXBpVXJsLCBhY2Nlc3NUb2tlbiwgcGF5ZWVVaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL3BheWVlcy8ke3BheWVlVWlkfWBcbiAgICBsb2coYERFTEVURSAke3VybH1gKVxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVQYXllZVBhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sXG4gIHBheWVlQ3JlYXRpb25SZXF1ZXN0OiBzdHJ1Y3Qub2JqZWN0KHtcbiAgICBwYXllZU5hbWU6ICdzdHJpbmcnLFxuICAgIHBob25lTnVtYmVyOiAnc3RyaW5nPycsXG4gICAgcGF5ZWVUeXBlOiBzdHJ1Y3QuZW51bShbJ0lORElWSURVQUwnLCAnQlVTSU5FU1MnXSksXG4gICAgZmlyc3ROYW1lOiAnc3RyaW5nPycsXG4gICAgbWlkZGxlTmFtZTogJ3N0cmluZz8nLFxuICAgIGxhc3ROYW1lOiAnc3RyaW5nPycsXG4gICAgYnVzaW5lc3NOYW1lOiAnc3RyaW5nPycsXG4gICAgZGF0ZU9mQmlydGg6ICdkYXRlPycsXG4gICAgYWNjb3VudHM6IHN0cnVjdC5vcHRpb25hbChbc3RydWN0Lm9iamVjdCh7XG4gICAgICBkZXNjcmlwdGlvbjogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0QWNjb3VudDogJ2Jvb2xlYW4nLFxuICAgICAgY291bnRyeUNvZGU6ICdzdHJpbmcnLFxuICAgICAgYWNjb3VudElkZW50aWZpZXI6ICdzdHJpbmcnLFxuICAgICAgYmFua0lkZW50aWZpZXI6ICdzdHJpbmcnLFxuICAgICAgYmFua0lkZW50aWZpZXJUeXBlOiBzdHJ1Y3QuZW51bShbJ1NPUlRfQ09ERScsICdTV0lGVCcsICdJQkFOJywgJ0FCQScsICdBQkFfV0lSRScsICdBQkFfQUNIJ10pXG4gICAgfSldKVxuICB9KVxufSlcblxuY29uc3QgZGVsZXRlUGF5ZWVQYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKHtcbiAgLi4ubWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLFxuICBwYXllZVVpZDogJ3V1aWQnXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBheWVlXG4iLCJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnXG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnXG5pbXBvcnQgeyBkZWZhdWx0SGVhZGVycyB9IGZyb20gJy4uL3V0aWxzL2h0dHAnXG5pbXBvcnQgeyBzdHJ1Y3QsIG1pbkFQSVBhcmFtZXRlckRlZmludGlvbiB9IGZyb20gJy4uL3V0aWxzL3ZhbGlkYXRvcidcblxuY29uc3QgbG9nID0gZGVidWcoJ3N0YXJsaW5nOnBheW1lbnQtc2VydmljZScpXG5cbi8qKlxuICogU2VydmljZSB0byBpbnRlcmFjdCB3aXRoIGEgY3VzdG9tZXIncyBwYXltZW50c1xuICovXG5jbGFzcyBQYXltZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYXltZW50IHNlcnZpY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHBheW1lbnQgb3JkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnBheW1lbnRPcmRlclVpZCAtIHRoZSBwYXltZW50IG9yZGVyIHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0UGF5bWVudE9yZGVyIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRQYXltZW50T3JkZXJQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIHBheW1lbnRPcmRlclVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvcGF5bWVudHMvbG9jYWwvcGF5bWVudC1vcmRlci8ke3BheW1lbnRPcmRlclVpZH1gXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBwYXltZW50IG9yZGVyJ3MgcGF5bWVudHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnBheW1lbnRPcmRlclVpZCAtIHRoZSBwYXltZW50IG9yZGVyIHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0UGF5bWVudE9yZGVyUGF5bWVudHMgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGdldFBheW1lbnRPcmRlclBheW1lbnRzUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBwYXltZW50T3JkZXJVaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL3BheW1lbnRzL2xvY2FsL3BheW1lbnQtb3JkZXIvJHtwYXltZW50T3JkZXJVaWR9L3BheW1lbnRzYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogTGlzdCBzdGFuZGluZyBvcmRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY291bnRVaWQgLSB0aGUgYWNjb3VudCB1aWQgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHN0YW5kaW5nIG9yZGVycyBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jYXRlZ29yeVVpZCAtIHRoZSBjYXRlZ29yeSB1aWQgb2YgdGhlIGNhdGVnb3J5IHRvIGdldCBzdGFuZGluZyBvcmRlcnMgb2ZcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGxpc3RTdGFuZGluZ09yZGVycyAocGFyYW1ldGVycykge1xuICAgIHBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgbGlzdFN0YW5kaW5nT3JkZXJzUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBhY2NvdW50VWlkLCBjYXRlZ29yeVVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvcGF5bWVudHMvbG9jYWwvYWNjb3VudC8ke2FjY291bnRVaWR9L2NhdGVnb3J5LyR7Y2F0ZWdvcnlVaWR9L3N0YW5kaW5nLW9yZGVyc2BcbiAgICBsb2coYEdFVCAke3VybH1gKVxuXG4gICAgcmV0dXJuIGF4aW9zKHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmwsXG4gICAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YW5kaW5nIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkIG9mIHRoZSBzdGFuZGluZyBvcmRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5jYXRlZ29yeVVpZCAtIHRoZSBjYXRlZ29yeSB1aWQgb2YgdGhlIHN0YW5kaW5nIG9yZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnBheW1lbnRPcmRlclVpZCAtIHRoZSBwYXltZW50IG9yZGVyIHVpZCBvZiB0aGUgc3RhbmRpbmcgb3JkZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGdldFN0YW5kaW5nT3JkZXIgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGdldFN0YW5kaW5nT3JkZXJQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIGNhdGVnb3J5VWlkLCBwYXltZW50T3JkZXJVaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL3BheW1lbnRzL2xvY2FsL2FjY291bnQvJHthY2NvdW50VWlkfS9jYXRlZ29yeS8ke2NhdGVnb3J5VWlkfS9zdGFuZGluZy1vcmRlcnMvJHtwYXltZW50T3JkZXJVaWR9YFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgZ2V0UGF5bWVudE9yZGVyUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgcGF5bWVudE9yZGVyVWlkOiAndXVpZCdcbn0pXG5cbmNvbnN0IGdldFBheW1lbnRPcmRlclBheW1lbnRzUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgcGF5bWVudE9yZGVyVWlkOiAndXVpZCdcbn0pXG5cbmNvbnN0IGxpc3RTdGFuZGluZ09yZGVyc1BhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sXG4gIGFjY291bnRVaWQ6ICd1dWlkJyxcbiAgY2F0ZWdvcnlVaWQ6ICd1dWlkJ1xufSlcblxuY29uc3QgZ2V0U3RhbmRpbmdPcmRlclBhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sXG4gIGFjY291bnRVaWQ6ICd1dWlkJyxcbiAgY2F0ZWdvcnlVaWQ6ICd1dWlkJyxcbiAgcGF5bWVudE9yZGVyVWlkOiAndXVpZCdcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gUGF5bWVudFxuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHsgZGVmYXVsdEhlYWRlcnMsIHBheWxvYWRIZWFkZXJzIH0gZnJvbSAnLi4vdXRpbHMvaHR0cCdcbmltcG9ydCB7IHN0cnVjdCwgbWluQVBJUGFyYW1ldGVyRGVmaW50aW9uIH0gZnJvbSAnLi4vdXRpbHMvdmFsaWRhdG9yJ1xuXG5jb25zdCBsb2cgPSBkZWJ1Zygnc3Rhcmxpbmc6c2F2aW5ncy1nb2FsLXNlcnZpY2UnKVxuXG4vKipcbiAqIFNlcnZpY2UgdG8gaW50ZXJhY3Qgd2l0aCBhIGN1c3RvbWVyJ3Mgc2F2aW5ncyBnb2Fsc1xuICovXG5jbGFzcyBTYXZpbmdzR29hbCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2F2aW5ncyBnb2FsIHNlcnZpY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgc2F2aW5ncyBnb2Fsc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hcGlVcmwgLSB0aGUgQVBJIFVSTFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2Nlc3NUb2tlbiAtIHRoZSBvYXV0aCBiZWFyZXIgdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjb3VudFVpZCAtIHRoZSBhY2NvdW50IHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0U2F2aW5nc0dvYWxzIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBnZXRTYXZpbmdzR29hbHNQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQgfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnQvJHthY2NvdW50VWlkfS9zYXZpbmdzLWdvYWxzYFxuICAgIGxvZyhgR0VUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzKGFjY2Vzc1Rva2VuKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgc2F2aW5ncyBnb2FsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnNhdmluZ3NHb2FsVWlkIC0gdGhlIHNhdmluZ3MgZ29hbCdzIHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZ2V0U2F2aW5nc0dvYWwgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGdldFNhdmluZ3NHb2FsUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBhY2NvdW50VWlkLCBzYXZpbmdzR29hbFVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudC8ke2FjY291bnRVaWR9L3NhdmluZ3MtZ29hbHMvJHtzYXZpbmdzR29hbFVpZH1gXG4gICAgbG9nKGBHRVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzYXZpbmdzIGdvYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY291bnRVaWQgLSB0aGUgYWNjb3VudCB1aWQgb2YgdGhlIGFjY291bnQgdG8gY3JlYXRlIHRoZSBzYXZpbmdzIGdvYWwgaW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMubmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBuZXcgc2F2aW5ncyBnb2FsXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcGFyYW1ldGVycy5jdXJyZW5jeSAtIElTTy00MjE3IDMgY2hhcmFjdGVyIGN1cnJlbmN5IGNvZGVcbiAgICogQHBhcmFtIHtudW1iZXI9fSBwYXJhbWV0ZXJzLnRhcmdldEFtb3VudCAtIHRoZSB0YXJnZXQgYW1vdW50IGluIG1pbm9yIHVuaXRzIChlLmcuIDEyMzQgPT4gwqMxMi4zNClcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXJhbWV0ZXJzLnRhcmdldEN1cnJlbmN5IC0gSVNPLTQyMTcgMyBjaGFyYWN0ZXIgY3VycmVuY3kgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhcmFtZXRlcnMuYmFzZTY0RW5jb2RlZFBob3RvIC0gYmFzZTY0IGVuY29kZWQgaW1hZ2UgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGdvYWxcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIGNyZWF0ZVNhdmluZ3NHb2FsIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHsgY3VycmVuY3k6ICdHQlAnLCB0YXJnZXRBbW91bnQ6IDAsIHRhcmdldEN1cnJlbmN5OiAnR0JQJyB9LCB0aGlzLm9wdGlvbnMsIHBhcmFtZXRlcnMpXG4gICAgY3JlYXRlU2F2aW5nc0dvYWxQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIG5hbWUsIGN1cnJlbmN5LCB0YXJnZXRBbW91bnQsIHRhcmdldEN1cnJlbmN5LCBiYXNlNjRFbmNvZGVkUGhvdG8gfSA9IHBhcmFtZXRlcnNcblxuICAgIGNvbnN0IHVybCA9IGAke2FwaVVybH0vYXBpL3YyL2FjY291bnQvJHthY2NvdW50VWlkfS9zYXZpbmdzLWdvYWxzYFxuICAgIGxvZyhgUFVUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IHBheWxvYWRIZWFkZXJzKGFjY2Vzc1Rva2VuKSxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY3VycmVuY3ksXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIG1pbm9yVW5pdHM6IHRhcmdldEFtb3VudCxcbiAgICAgICAgICBjdXJyZW5jeTogdGFyZ2V0Q3VycmVuY3lcbiAgICAgICAgfSxcbiAgICAgICAgYmFzZTY0RW5jb2RlZFBob3RvXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgc2F2aW5ncyBnb2FsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnNhdmluZ3NHb2FsVWlkIC0gdGhlIHNhdmluZ3MgZ29hbCdzIHVpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgZGVsZXRlU2F2aW5nc0dvYWwgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIGRlbGV0ZVNhdmluZ3NHb2FsUGFyYW1ldGVyVmFsaWRhdG9yKHBhcmFtZXRlcnMpXG4gICAgY29uc3QgeyBhcGlVcmwsIGFjY2Vzc1Rva2VuLCBhY2NvdW50VWlkLCBzYXZpbmdzR29hbFVpZCB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudC8ke2FjY291bnRVaWR9L3NhdmluZ3MtZ29hbHMvJHtzYXZpbmdzR29hbFVpZH1gXG4gICAgbG9nKGBERUxFVEUgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogZGVmYXVsdEhlYWRlcnMoYWNjZXNzVG9rZW4pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbW9uZXkgdG8gYSBzYXZpbmdzIGdvYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYXBpVXJsIC0gdGhlIEFQSSBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuYWNjZXNzVG9rZW4gLSB0aGUgb2F1dGggYmVhcmVyIHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY291bnRVaWQgLSB0aGUgYWNjb3VudCB1aWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMuc2F2aW5nc0dvYWxVaWQgLSB0aGUgc2F2aW5ncyBnb2FsJ3MgdWlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnRyYW5zZmVyVWlkIC0gYSB0cmFuc2FjdGlvbiBJRCBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1ldGVycy5hbW91bnQgLSBhbW91bnQgaW4gdGhlIG1pbm9yIHVuaXRzIG9mIHRoZSBnaXZlbiBjdXJyZW5jeTsgZWcgcGVuY2UgaW4gR0JQLCBjZW50cyBpbiBFVVJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXJhbWV0ZXJzLmN1cnJlbmN5IC0gSVNPLTQyMTcgMyBjaGFyYWN0ZXIgY3VycmVuY3kgY29kZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIHRoZSBodHRwIHJlcXVlc3QgcHJvbWlzZVxuICAgKi9cbiAgYWRkTW9uZXlUb1NhdmluZ3NHb2FsIChwYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHsgY3VycmVuY3k6ICdHQlAnIH0sIHRoaXMub3B0aW9ucywgcGFyYW1ldGVycylcbiAgICBhZGRNb25leVRvU2F2aW5nc0dvYWxQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIHNhdmluZ3NHb2FsVWlkLCB0cmFuc2ZlclVpZCwgYW1vdW50LCBjdXJyZW5jeSB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudC8ke2FjY291bnRVaWR9L3NhdmluZ3MtZ29hbHMvJHtzYXZpbmdzR29hbFVpZH0vYWRkLW1vbmV5LyR7dHJhbnNmZXJVaWR9YFxuICAgIGxvZyhgUFVUICR7dXJsfWApXG5cbiAgICByZXR1cm4gYXhpb3Moe1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnM6IHBheWxvYWRIZWFkZXJzKGFjY2Vzc1Rva2VuKSxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgYW1vdW50OiB7XG4gICAgICAgICAgY3VycmVuY3ksXG4gICAgICAgICAgbWlub3JVbml0czogYW1vdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBXaXRoZHJhdyBtb25leSBmcm9tIGEgc2F2aW5ncyBnb2FsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFwaVVybCAtIHRoZSBBUEkgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLmFjY2Vzc1Rva2VuIC0gdGhlIG9hdXRoIGJlYXJlciB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy5hY2NvdW50VWlkIC0gdGhlIGFjY291bnQgdWlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnNhdmluZ3NHb2FsVWlkIC0gdGhlIHNhdmluZ3MgZ29hbCdzIHVpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVycy50cmFuc2ZlclVpZCAtIGEgdHJhbnNhY3Rpb24gSUQgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtZXRlcnMuYW1vdW50IC0gYW1vdW50IGluIHRoZSBtaW5vciB1bml0cyBvZiB0aGUgZ2l2ZW4gY3VycmVuY3k7IGVnIHBlbmNlIGluIEdCUCwgY2VudHMgaW4gRVVSXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcGFyYW1ldGVycy5jdXJyZW5jeSAtIElTTy00MjE3IDMgY2hhcmFjdGVyIGN1cnJlbmN5IGNvZGVcbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSB0aGUgaHR0cCByZXF1ZXN0IHByb21pc2VcbiAgICovXG4gIHdpdGhkcmF3TW9uZXlGcm9tU2F2aW5nc0dvYWwgKHBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgeyBjdXJyZW5jeTogJ0dCUCcgfSwgdGhpcy5vcHRpb25zLCBwYXJhbWV0ZXJzKVxuICAgIHdpdGhkcmF3TW9uZXlGcm9tU2F2aW5nc0dvYWxQYXJhbWV0ZXJWYWxpZGF0b3IocGFyYW1ldGVycylcbiAgICBjb25zdCB7IGFwaVVybCwgYWNjZXNzVG9rZW4sIGFjY291bnRVaWQsIHNhdmluZ3NHb2FsVWlkLCB0cmFuc2ZlclVpZCwgYW1vdW50LCBjdXJyZW5jeSB9ID0gcGFyYW1ldGVyc1xuXG4gICAgY29uc3QgdXJsID0gYCR7YXBpVXJsfS9hcGkvdjIvYWNjb3VudC8ke2FjY291bnRVaWR9L3NhdmluZ3MtZ29hbHMvJHtzYXZpbmdzR29hbFVpZH0vd2l0aGRyYXctbW9uZXkvJHt0cmFuc2ZlclVpZH1gXG4gICAgbG9nKGBQVVQgJHt1cmx9YClcblxuICAgIHJldHVybiBheGlvcyh7XG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVyczogcGF5bG9hZEhlYWRlcnMoYWNjZXNzVG9rZW4pLFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICBjdXJyZW5jeSxcbiAgICAgICAgICBtaW5vclVuaXRzOiBhbW91bnRcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGdldFNhdmluZ3NHb2Fsc1BhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sXG4gIGFjY291bnRVaWQ6ICd1dWlkJ1xufSlcblxuY29uc3QgZ2V0U2F2aW5nc0dvYWxQYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKHtcbiAgLi4ubWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLFxuICBhY2NvdW50VWlkOiAndXVpZCcsXG4gIHNhdmluZ3NHb2FsVWlkOiAndXVpZCdcbn0pXG5cbmNvbnN0IGRlbGV0ZVNhdmluZ3NHb2FsUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgYWNjb3VudFVpZDogJ3V1aWQnLFxuICBzYXZpbmdzR29hbFVpZDogJ3V1aWQnXG59KVxuXG5jb25zdCBjcmVhdGVTYXZpbmdzR29hbFBhcmFtZXRlclZhbGlkYXRvciA9IHN0cnVjdC5pbnRlcmZhY2Uoe1xuICAuLi5taW5BUElQYXJhbWV0ZXJEZWZpbnRpb24sXG4gIGFjY291bnRVaWQ6ICd1dWlkJyxcbiAgbmFtZTogJ3N0cmluZycsXG4gIGN1cnJlbmN5OiAnc3RyaW5nJyxcbiAgdGFyZ2V0QW1vdW50OiAnbnVtYmVyJyxcbiAgdGFyZ2V0Q3VycmVuY3k6ICdzdHJpbmcnLFxuICBiYXNlNjRFbmNvZGVkUGhvdG86ICdzdHJpbmc/J1xufSlcblxuY29uc3QgYWRkTW9uZXlUb1NhdmluZ3NHb2FsUGFyYW1ldGVyVmFsaWRhdG9yID0gc3RydWN0LmludGVyZmFjZSh7XG4gIC4uLm1pbkFQSVBhcmFtZXRlckRlZmludGlvbixcbiAgYWNjb3VudFVpZDogJ3V1aWQnLFxuICBzYXZpbmdzR29hbFVpZDogJ3V1aWQnLFxuICB0cmFuc2ZlclVpZDogJ3V1aWQnLFxuICBhbW91bnQ6ICdudW1iZXInLFxuICBjdXJyZW5jeTogJ3N0cmluZydcbn0pXG5cbmNvbnN0IHdpdGhkcmF3TW9uZXlGcm9tU2F2aW5nc0dvYWxQYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKHtcbiAgLi4ubWluQVBJUGFyYW1ldGVyRGVmaW50aW9uLFxuICBhY2NvdW50VWlkOiAndXVpZCcsXG4gIHNhdmluZ3NHb2FsVWlkOiAndXVpZCcsXG4gIHRyYW5zZmVyVWlkOiAndXVpZCcsXG4gIGFtb3VudDogJ251bWJlcicsXG4gIGN1cnJlbmN5OiAnc3RyaW5nJ1xufSlcblxubW9kdWxlLmV4cG9ydHMgPSBTYXZpbmdzR29hbFxuIiwiaW1wb3J0IEFjY291bnQgZnJvbSAnLi9lbnRpdGllcy9hY2NvdW50J1xuaW1wb3J0IEFjY291bnRIb2xkZXIgZnJvbSAnLi9lbnRpdGllcy9hY2NvdW50SG9sZGVyJ1xuaW1wb3J0IEFkZHJlc3MgZnJvbSAnLi9lbnRpdGllcy9hZGRyZXNzJ1xuaW1wb3J0IEZlZWRJdGVtIGZyb20gJy4vZW50aXRpZXMvZmVlZEl0ZW0nXG5pbXBvcnQgQ2FyZCBmcm9tICcuL2VudGl0aWVzL2NhcmQnXG5pbXBvcnQgT0F1dGggZnJvbSAnLi9lbnRpdGllcy9vYXV0aCdcbmltcG9ydCBQYXllZSBmcm9tICcuL2VudGl0aWVzL3BheWVlJ1xuaW1wb3J0IFBheW1lbnQgZnJvbSAnLi9lbnRpdGllcy9wYXltZW50J1xuaW1wb3J0IE1hbmRhdGUgZnJvbSAnLi9lbnRpdGllcy9tYW5kYXRlJ1xuaW1wb3J0IFNhdmluZ3NHb2FsIGZyb20gJy4vZW50aXRpZXMvc2F2aW5nc0dvYWwnXG5pbXBvcnQgSWRlbnRpdHkgZnJvbSAnLi9lbnRpdGllcy9pZGVudGl0eSdcblxuLyoqXG4gKiBAcHJvcGVydHkge0lkZW50aXR5fSBpZGVudGl0eVxuICogQHByb3BlcnR5IHtBY2NvdW50SG9sZGVyfSBhY2NvdW50SG9sZGVyXG4gKiBAcHJvcGVydHkge0FjY291bnR9IGFjY291bnRcbiAqIEBwcm9wZXJ0eSB7QWRkcmVzc30gYWRkcmVzc1xuICogQHByb3BlcnR5IHtGZWVkSXRlbX0gZmVlZEl0ZW1cbiAqIEBwcm9wZXJ0eSB7UGF5bWVudH0gcGF5bWVudFxuICogQHByb3BlcnR5IHtNYW5kYXRlfSBtYW5kYXRlXG4gKiBAcHJvcGVydHkge1BheWVlfSBwYXllZVxuICogQHByb3BlcnR5IHtDYXJkfSBjYXJkXG4gKiBAcHJvcGVydHkge1NhdmluZ3NHb2FsfSBzYXZpbmdzR29hbFxuICogQHByb3BlcnR5IHtPQXV0aH0gb0F1dGhcbiAqL1xuY2xhc3MgU3Rhcmxpbmcge1xuICAvKipcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBzdGFybGluZyBjbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgYXBpVXJsOiAnaHR0cHM6Ly9hcGkuc3RhcmxpbmdiYW5rLmNvbScsXG4gICAgICBjbGllbnRJZDogJycsXG4gICAgICBjbGllbnRTZWNyZXQ6ICcnXG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucylcblxuICAgIHRoaXMuaWRlbnRpdHkgPSBuZXcgSWRlbnRpdHkodGhpcy5jb25maWcpXG4gICAgdGhpcy5hY2NvdW50SG9sZGVyID0gbmV3IEFjY291bnRIb2xkZXIodGhpcy5jb25maWcpXG4gICAgdGhpcy5hY2NvdW50ID0gbmV3IEFjY291bnQodGhpcy5jb25maWcpXG4gICAgdGhpcy5hZGRyZXNzID0gbmV3IEFkZHJlc3ModGhpcy5jb25maWcpXG4gICAgdGhpcy5mZWVkSXRlbSA9IG5ldyBGZWVkSXRlbSh0aGlzLmNvbmZpZylcbiAgICB0aGlzLnBheW1lbnQgPSBuZXcgUGF5bWVudCh0aGlzLmNvbmZpZylcbiAgICB0aGlzLm1hbmRhdGUgPSBuZXcgTWFuZGF0ZSh0aGlzLmNvbmZpZylcbiAgICB0aGlzLnBheWVlID0gbmV3IFBheWVlKHRoaXMuY29uZmlnKVxuICAgIHRoaXMuY2FyZCA9IG5ldyBDYXJkKHRoaXMuY29uZmlnKVxuICAgIHRoaXMuc2F2aW5nc0dvYWwgPSBuZXcgU2F2aW5nc0dvYWwodGhpcy5jb25maWcpXG4gICAgdGhpcy5vQXV0aCA9IG5ldyBPQXV0aCh0aGlzLmNvbmZpZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXJsaW5nXG4iLCJleHBvcnQgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSAoYWNjZXNzVG9rZW4pID0+ICh7XG4gIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YFxufSlcblxuZXhwb3J0IGNvbnN0IHBheWxvYWRIZWFkZXJzID0gKGFjY2Vzc1Rva2VuKSA9PiAoe1xuICAuLi5kZWZhdWx0SGVhZGVycyhhY2Nlc3NUb2tlbiksXG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbn0pXG4iLCJjb25zdCBzdXBlcnN0cnVjdCA9IHJlcXVpcmUoJ3N1cGVyc3RydWN0Jykuc3VwZXJzdHJ1Y3RcbmV4cG9ydCBjb25zdCBzdHJ1Y3QgPSBzdXBlcnN0cnVjdCh7XG4gIHR5cGVzOiB7XG4gICAgdXVpZDogdmFsdWUgPT4gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bNF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kL2kudGVzdCh2YWx1ZSksXG4gICAgeWVhck1vbnRoOiB2YWx1ZSA9PiAvXlswLTldezR9LSg/OjFbMC0yXXwwWzEtOV0pJC8udGVzdCh2YWx1ZSksXG4gICAgZGF0ZTogdmFsdWUgPT4gL15bMC05XXs0fS0oPzoxWzAtMl18MFsxLTldKS0oPzozWzAxXXxbMTJdXFxkfDBbMS05XSkkLy50ZXN0KHZhbHVlKSxcbiAgICB0aW1lc3RhbXA6IHZhbHVlID0+IC9eKCg/OlsxLTldWzAtOV0qKT9bMC05XXs0fSktKDFbMC0yXXwwWzEtOV0pLSgzWzAxXXwwWzEtOV18WzEyXVswLTldKVQoMlswLTNdfFswMV1bMC05XSk6KFswLTVdWzAtOV0pOihbMC01XVswLTldKShcXC5bMC05XSspPyhaKT8kLy50ZXN0KHZhbHVlKVxuICB9XG59KVxuZXhwb3J0IGNvbnN0IG1pbkFQSVBhcmFtZXRlckRlZmludGlvbiA9IHsgYWNjZXNzVG9rZW46ICdzdHJpbmcnLCBhcGlVcmw6ICdzdHJpbmcnIH1cbmV4cG9ydCBjb25zdCBtaW5BUElQYXJhbWV0ZXJWYWxpZGF0b3IgPSBzdHJ1Y3QuaW50ZXJmYWNlKG1pbkFQSVBhcmFtZXRlckRlZmludGlvbilcbiJdfQ=="}