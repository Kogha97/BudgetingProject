(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.starling = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.account = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:account-service');
  /**
   * Service to interact with a customer's account
   */

  var Account = /*#__PURE__*/function () {
    /**
     * Creates an instance of the account client
     * @param {Object} options - application config
     */
    function Account(options) {
      _classCallCheck(this, Account);

      this.options = options;
    }
    /**
     * Get an account holder's bank accounts
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @return {Promise} - the http request promise
     */


    _createClass(Account, [{
      key: "getAccounts",
      value: function getAccounts(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/accounts");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get an account's bank identifiers
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountIdentifiers",
      value: function getAccountIdentifiers(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getAccountIdentifiersParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            accountUid = _parameters2.accountUid;
        var url = "".concat(apiUrl, "/api/v2/accounts/").concat(accountUid, "/identifiers");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get an account's balance
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountBalance",
      value: function getAccountBalance(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getAccountBalanceParameterValidator(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken,
            accountUid = _parameters3.accountUid;
        var url = "".concat(apiUrl, "/api/v2/accounts/").concat(accountUid, "/balance");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get whether there are available funds for a requested amount
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {number} parameters.targetAmountInMinorUnits - the target amount in minor units
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getConfirmationOfFunds",
      value: function getConfirmationOfFunds(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getConfirmationOfFundsParameterValidator(parameters);
        var _parameters4 = parameters,
            apiUrl = _parameters4.apiUrl,
            accessToken = _parameters4.accessToken,
            accountUid = _parameters4.accountUid,
            targetAmountInMinorUnits = _parameters4.targetAmountInMinorUnits;
        var url = "".concat(apiUrl, "/api/v2/accounts/").concat(accountUid, "/confirmation-of-funds");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken),
          params: {
            targetAmountInMinorUnits: targetAmountInMinorUnits
          }
        });
      }
      /**
       * Get list of statement periods which are available for an account
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getStatementPeriods",
      value: function getStatementPeriods(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getStatementPeriodsParameterValidator(parameters);
        var _parameters5 = parameters,
            apiUrl = _parameters5.apiUrl,
            accessToken = _parameters5.accessToken,
            accountUid = _parameters5.accountUid;
        var url = "".concat(apiUrl, "/api/v2/accounts/").concat(accountUid, "/statement/available-periods");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Download a statement for a given statement period
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string=} parameters.yearMonth - the statement period's year month (yyyy-MM)
       * @param {string=} parameters.format - one of 'application/pdf' or 'text/csv'
       * @param {string=} parameters.responseType - the axios responseType for the request
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getStatementForPeriod",
      value: function getStatementForPeriod(parameters) {
        parameters = Object.assign({}, {
          yearMonth: new Date().toISOString().slice(0, 7),
          format: 'text/csv',
          responseType: 'stream'
        }, this.options, parameters);
        getStatementForPeriodParameterValidator(parameters);
        var _parameters6 = parameters,
            apiUrl = _parameters6.apiUrl,
            accessToken = _parameters6.accessToken,
            accountUid = _parameters6.accountUid,
            format = _parameters6.format,
            yearMonth = _parameters6.yearMonth,
            responseType = _parameters6.responseType;
        var url = "".concat(apiUrl, "/api/v2/accounts/").concat(accountUid, "/statement/download");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: _objectSpread(_objectSpread({}, (0, _http.defaultHeaders)(accessToken)), {}, {
            Accept: format
          }),
          params: {
            yearMonth: yearMonth
          },
          responseType: responseType
        });
      }
      /**
       * Download a statement for a given date range
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.start - the beginning of the statement date range (yyyy-MM-dd)
       * @param {string=} parameters.end - the end of the statement date range (yyyy-MM-dd)
       * @param {string=} parameters.format - one of 'application/pdf' or 'text/csv'
       * @param {string=} parameters.responseType - the axios responseType for the request
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getStatementForRange",
      value: function getStatementForRange(parameters) {
        parameters = Object.assign({}, {
          format: 'text/csv',
          responseType: 'stream'
        }, this.options, parameters);
        getStatementForRangeParameterValidator(parameters);
        var _parameters7 = parameters,
            apiUrl = _parameters7.apiUrl,
            accessToken = _parameters7.accessToken,
            accountUid = _parameters7.accountUid,
            start = _parameters7.start,
            end = _parameters7.end,
            format = _parameters7.format,
            responseType = _parameters7.responseType;
        var url = "".concat(apiUrl, "/api/v2/accounts/").concat(accountUid, "/statement/downloadForDateRange");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: _objectSpread(_objectSpread({}, (0, _http.defaultHeaders)(accessToken)), {}, {
            Accept: format
          }),
          params: {
            start: start,
            end: end
          },
          responseType: responseType
        });
      }
    }]);

    return Account;
  }();

  var getAccountIdentifiersParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid'
  }));

  var getAccountBalanceParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid'
  }));

  var getConfirmationOfFundsParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    targetAmountInMinorUnits: 'number'
  }));

  var getStatementPeriodsParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid'
  }));

  var getStatementForPeriodParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    yearMonth: 'yearMonth',
    format: _validator.struct["enum"](['application/pdf', 'text/csv']),
    responseType: 'string'
  }));

  var getStatementForRangeParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    start: 'date',
    end: 'date?',
    format: _validator.struct["enum"](['application/pdf', 'text/csv']),
    responseType: 'string'
  }));

  module.exports = Account;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],2:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.accountHolder = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:account-holder-service');
  /**
   * Service to interact with an account holder
   */

  var AccountHolder = /*#__PURE__*/function () {
    /**
     * Creates an instance of the account holder client
     * @param {Object} options - application config
     */
    function AccountHolder(options) {
      _classCallCheck(this, AccountHolder);

      this.options = options;
    }
    /**
     * Get basic information about the account holder
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @return {Promise} - the http request promise
     */


    _createClass(AccountHolder, [{
      key: "getAccountHolder",
      value: function getAccountHolder(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get the name of the account holder
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountHolderName",
      value: function getAccountHolderName(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder/name");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get an individual account holder's details
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountHolderIndividual",
      value: function getAccountHolderIndividual(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder/individual");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a joint account holder's details
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountHolderJoint",
      value: function getAccountHolderJoint(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters4 = parameters,
            apiUrl = _parameters4.apiUrl,
            accessToken = _parameters4.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder/joint");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a business account holder's details
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountHolderBusiness",
      value: function getAccountHolderBusiness(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters5 = parameters,
            apiUrl = _parameters5.apiUrl,
            accessToken = _parameters5.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder/business");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a business account holder's registered address
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountHolderBusinessRegisteredAddress",
      value: function getAccountHolderBusinessRegisteredAddress(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters6 = parameters,
            apiUrl = _parameters6.apiUrl,
            accessToken = _parameters6.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder/business/registered-address");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a business account holder's correspondence address
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAccountHolderBusinessCorrespondenceAddress",
      value: function getAccountHolderBusinessCorrespondenceAddress(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters7 = parameters,
            apiUrl = _parameters7.apiUrl,
            accessToken = _parameters7.accessToken;
        var url = "".concat(apiUrl, "/api/v2/account-holder/business/correspondence-address");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return AccountHolder;
  }();

  module.exports = AccountHolder;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],3:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.address = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:address-service');
  /**
   * Service to interact with a customer address
   */

  var Address = /*#__PURE__*/function () {
    /**
     * Creates an instance of the address client
     * @param {Object} options - configuration parameters
     */
    function Address(options) {
      _classCallCheck(this, Address);

      this.options = options;
    }
    /**
     * Retrieves a customer's address
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token.
     * @return {Promise} - the http request promise
     */


    _createClass(Address, [{
      key: "getAddresses",
      value: function getAddresses(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/addresses");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return Address;
  }();

  module.exports = Address;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],4:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.card = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:card-service');
  /**
   * Service to interact with a customer card
   */

  var Card = /*#__PURE__*/function () {
    /**
     * Creates an instance of the client's card
     * @param {Object} options - configuration parameters
     */
    function Card(options) {
      _classCallCheck(this, Card);

      this.options = options;
    }
    /**
     * Get all the cards for an account holder
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @return {Promise} - the http request promise
     */


    _createClass(Card, [{
      key: "getCards",
      value: function getCards(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/cards");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Update card lock
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether the card should be locked. Set to false to lock, true to unlock.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardLock",
      value: function updateCardLock(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'enabled'
        }));
      }
      /**
       * Update ATM withdrawal control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether ATM withdrawals should be allowed. Set to false to block, true to allow.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardATMControl",
      value: function updateCardATMControl(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'atm-enabled'
        }));
      }
      /**
       * Update online payments control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether online payments should be allowed. Set to false to block, true to allow.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardOnlineControl",
      value: function updateCardOnlineControl(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'online-enabled'
        }));
      }
      /**
       * Update mobile wallet payments control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether mobile wallet payments should be allowed. Set to false to block, true to allow.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardMobileWalletControl",
      value: function updateCardMobileWalletControl(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'mobile-wallet-enabled'
        }));
      }
      /**
       * Update gambling payments control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether gambling payments should be allowed. Set to false to block, true to allow.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardGamblingControl",
      value: function updateCardGamblingControl(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'gambling-enabled'
        }));
      }
      /**
       * Update card present payments (contactless and chip and pin) control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether card present payments (contactless and chip and pin) should be allowed. Set to false to block, true to allow.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardPresentControl",
      value: function updateCardPresentControl(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'pos-enabled'
        }));
      }
      /**
       * Update magstripe payments control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether magstripe payments should be allowed. Set to false to block, true to allow.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardMagstripeControl",
      value: function updateCardMagstripeControl(parameters) {
        return this.updateCardControl(_objectSpread(_objectSpread({}, parameters), {}, {
          endpoint: 'mag-stripe-enabled'
        }));
      }
      /**
       * Update a card control
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.cardUid - the card uid
       * @param {boolean} parameters.enabled - Whether the control should be should be locked. Set to false to lock, true to unlock.
       * @param {string} parameters.endpoint - the last segment of the endpoint name
       * @return {Promise} - the http request promise
       */

    }, {
      key: "updateCardControl",
      value: function updateCardControl(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        updateCardControlParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            cardUid = _parameters2.cardUid,
            enabled = _parameters2.enabled,
            endpoint = _parameters2.endpoint;
        var url = "".concat(apiUrl, "/api/v2/cards/").concat(cardUid, "/controls/").concat(endpoint);
        log("PUT ".concat(url));
        return (0, _axios["default"])({
          method: 'PUT',
          url: url,
          headers: (0, _http.payloadHeaders)(accessToken),
          data: JSON.stringify({
            enabled: enabled
          })
        });
      }
    }]);

    return Card;
  }();

  var updateCardControlParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    cardUid: 'uuid',
    enabled: 'boolean'
  }));

  module.exports = Card;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],5:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.feedItem = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:feed-item-service');
  /**
   * Service to interact with a customer's feed items
   */

  var FeedItem = /*#__PURE__*/function () {
    /**
     * Create a new feed item service
     * @param {Object} options - configuration parameters
     */
    function FeedItem(options) {
      _classCallCheck(this, FeedItem);

      this.options = options;
    }
    /**
     * Get feed items created between two timestamps
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @param {string} parameters.accountUid - the account uid
     * @param {string} parameters.categoryUid - the category uid
     * @param {string} parameters.minTransactionTimestamp - timestamp e.g. '2019-10-25T12:34:56.789Z'
     * @param {string} parameters.maxTransactionTimestamp - timestamp e.g. '2019-10-26T12:34:56.789Z'
     * @return {Promise} - the http request promise
     */


    _createClass(FeedItem, [{
      key: "getFeedItemsBetween",
      value: function getFeedItemsBetween(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getFeedItemsBetweenParameterValidator(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken,
            accountUid = _parameters.accountUid,
            categoryUid = _parameters.categoryUid,
            minTransactionTimestamp = _parameters.minTransactionTimestamp,
            maxTransactionTimestamp = _parameters.maxTransactionTimestamp;
        var url = "".concat(apiUrl, "/api/v2/feed/account/").concat(accountUid, "/category/").concat(categoryUid, "/transactions-between");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          params: {
            minTransactionTimestamp: minTransactionTimestamp,
            maxTransactionTimestamp: maxTransactionTimestamp
          },
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a feed item
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.categoryUid - the category uid
       * @param {string} parameters.feedItemUid - the feed item uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getFeedItem",
      value: function getFeedItem(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getFeedItemParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            accountUid = _parameters2.accountUid,
            categoryUid = _parameters2.categoryUid,
            feedItemUid = _parameters2.feedItemUid;
        var url = "".concat(apiUrl, "/api/v2/feed/account/").concat(accountUid, "/category/").concat(categoryUid, "/").concat(feedItemUid);
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get feed items created or updated since a given timestamp
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.categoryUid - the category uid
       * @param {string} parameters.changesSince - timestamp e.g. '2019-10-25T12:34:56.789Z'
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getFeedItemsChangedSince",
      value: function getFeedItemsChangedSince(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getFeedItemsChangedSinceParameterValidator(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken,
            accountUid = _parameters3.accountUid,
            categoryUid = _parameters3.categoryUid,
            changesSince = _parameters3.changesSince;
        var url = "".concat(apiUrl, "/api/v2/feed/account/").concat(accountUid, "/category/").concat(categoryUid);
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          params: {
            changesSince: changesSince
          },
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return FeedItem;
  }();

  var getFeedItemsBetweenParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    categoryUid: 'uuid',
    minTransactionTimestamp: 'timestamp',
    maxTransactionTimestamp: 'timestamp'
  }));

  var getFeedItemParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    categoryUid: 'uuid',
    feedItemUid: 'uuid'
  }));

  var getFeedItemsChangedSinceParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    categoryUid: 'uuid',
    changesSince: 'timestamp'
  }));

  module.exports = FeedItem;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],6:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.identity = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:identity-service');
  /**
   * Service to interact with the API User identities endpoints
   */

  var Identity = /*#__PURE__*/function () {
    /**
     * Creates an instance of the identity client
     * @param {Object} options - configuration parameters
     */
    function Identity(options) {
      _classCallCheck(this, Identity);

      this.options = options;
    }
    /**
     * Get the current token identity
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token.
     * @return {Promise} - the http request promise
     */


    _createClass(Identity, [{
      key: "getTokenIdentity",
      value: function getTokenIdentity(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/identity/token");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get the authorising individual's identity
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getAuthorisingIndividual",
      value: function getAuthorisingIndividual(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken;
        var url = "".concat(apiUrl, "/api/v2/identity/individual");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return Identity;
  }();

  module.exports = Identity;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],7:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.mandate = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:mandate-service');
  /**
   * Service to interact with a customer's mandates
   */

  var Mandate = /*#__PURE__*/function () {
    /**
     * Create a new mandate service
     * @param {Object} options - configuration parameters
     */
    function Mandate(options) {
      _classCallCheck(this, Mandate);

      this.options = options;
    }
    /**
     * Gets a list of the customer's current direct debit mandates
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @return {Promise} - the http request promise
     */


    _createClass(Mandate, [{
      key: "listMandates",
      value: function listMandates(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/direct-debit/mandates");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Gets a specific direct debit mandate
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.mandateUid - unique identifier of the mandate
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getMandate",
      value: function getMandate(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getMandateParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            mandateUid = _parameters2.mandateUid;
        var url = "".concat(apiUrl, "/api/v2/direct-debit/mandates/").concat(mandateUid);
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Deletes specific direct debit mandate
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token.
       * @param {string} parameters.mandateUid - the unique mandate ID
       * @return {Promise} - the http request promise
       */

    }, {
      key: "deleteMandate",
      value: function deleteMandate(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        deleteMandateParameterValidator(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken,
            mandateUid = _parameters3.mandateUid;
        var url = "".concat(apiUrl, "/api/v2/direct-debit/mandates/").concat(mandateUid);
        log("DELETE ".concat(url));
        return (0, _axios["default"])({
          method: 'DELETE',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return Mandate;
  }();

  var getMandateParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    mandateUid: 'uuid'
  }));

  var deleteMandateParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    mandateUid: 'uuid'
  }));

  module.exports = Mandate;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],8:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.validator);
    global.oauth = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var ACCESS_TOKEN_GRANT_TYPE = 'authorization_code';
  var REFRESH_TOKEN_GRANT_TYPE = 'refresh_token';
  var log = (0, _debug["default"])('starling:oauth-service');
  /**
   * Service to interact with a the oauth endpoint
   */

  var OAuth = /*#__PURE__*/function () {
    /**
     * Create a new oauth service
     * @param {Object} options - configuration parameters
     */
    function OAuth(options) {
      _classCallCheck(this, OAuth);

      this.options = options;
    }
    /**
     * Exchanges the authorization code for an access token
     * @param {string} authorizationCode - the authorization code, acquired from the user agent after the user authenticates with starling
     * @return {Promise} - the http request promise
     */


    _createClass(OAuth, [{
      key: "getAccessToken",
      value: function getAccessToken(authorizationCode) {
        return this.getOAuthToken({
          queryParams: {
            code: authorizationCode,
            grant_type: ACCESS_TOKEN_GRANT_TYPE,
            client_id: this.options.clientId,
            client_secret: this.options.clientSecret,
            redirect_uri: this.options.redirectUri
          }
        });
      }
      /**
       * Exchanges the authorization code for an access token
       * @param {string} refreshToken - the oauth refresh token, used when the access token expires to claim a new access token.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "refreshAccessToken",
      value: function refreshAccessToken(refreshToken) {
        return this.getOAuthToken({
          queryParams: {
            refresh_token: refreshToken,
            grant_type: REFRESH_TOKEN_GRANT_TYPE,
            client_id: this.options.clientId,
            client_secret: this.options.clientSecret
          }
        });
      }
      /**
       * Gets the access token from the starling OAuth endpoint
       * @param {string} parameters.apiUrl - the OAuth url
       * @param {object} parameters.queryParams - the query params passed to the OAuth endpoint as per the OAuth spec
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getOAuthToken",
      value: function getOAuthToken(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getOAuthTokenParameterValidator(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            queryParams = _parameters.queryParams;
        var url = "".concat(apiUrl, "/oauth/access-token");
        log("POST ".concat(url, " queryParams:").concat(JSON.stringify(queryParams)));
        return (0, _axios["default"])({
          url: url,
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json'
          },
          params: queryParams
        });
      }
    }]);

    return OAuth;
  }();

  var getOAuthTokenParameterValidator = _validator.struct["interface"]({
    apiUrl: 'string',
    queryParams: _validator.struct.union([_validator.struct.object({
      client_id: 'string',
      client_secret: 'string',
      grant_type: _validator.struct.literal(ACCESS_TOKEN_GRANT_TYPE),
      code: 'string',
      redirect_uri: 'string'
    }), _validator.struct.object({
      client_id: 'string',
      client_secret: 'string',
      grant_type: _validator.struct.literal(REFRESH_TOKEN_GRANT_TYPE),
      refresh_token: 'string'
    })])
  });

  module.exports = OAuth;
});

},{"../utils/validator":14,"axios":undefined,"debug":undefined}],9:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.payee = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:payee-service');
  /**
   * Service to interact with an account holder's payees
   */

  var Payee = /*#__PURE__*/function () {
    /**
     * Create a new payee service
     * @param {Object} options - configuration parameters
     */
    function Payee(options) {
      _classCallCheck(this, Payee);

      this.options = options;
    }
    /**
     * Get an account holder's payees
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token.
     * @return {Promise} - the http request promise
     */


    _createClass(Payee, [{
      key: "getPayees",
      value: function getPayees(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        (0, _validator.minAPIParameterValidator)(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken;
        var url = "".concat(apiUrl, "/api/v2/payees");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Create a new payee
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token.
       * @param {Object} parameters.payeeCreationRequest - the payee creation request.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "createPayee",
      value: function createPayee(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        createPayeeParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            payeeCreationRequest = _parameters2.payeeCreationRequest;
        var url = "".concat(apiUrl, "/api/v2/payees");
        log("PUT ".concat(url));
        return (0, _axios["default"])({
          method: 'PUT',
          url: url,
          headers: (0, _http.payloadHeaders)(accessToken),
          data: JSON.stringify(payeeCreationRequest)
        });
      }
      /**
       * Delete an account holder's payee
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token.
       * @param {string} parameters.payeeUid - the payeeUid of the payee to be deleted.
       * @return {Promise} - the http request promise
       */

    }, {
      key: "deletePayee",
      value: function deletePayee(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        deletePayeeParameterValidator(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken,
            payeeUid = _parameters3.payeeUid;
        var url = "".concat(apiUrl, "/api/v2/payees/").concat(payeeUid);
        log("DELETE ".concat(url));
        return (0, _axios["default"])({
          method: 'DELETE',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return Payee;
  }();

  var createPayeeParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    payeeCreationRequest: _validator.struct.object({
      payeeName: 'string',
      phoneNumber: 'string?',
      payeeType: _validator.struct["enum"](['INDIVIDUAL', 'BUSINESS']),
      firstName: 'string?',
      middleName: 'string?',
      lastName: 'string?',
      businessName: 'string?',
      dateOfBirth: 'date?',
      accounts: _validator.struct.optional([_validator.struct.object({
        description: 'string',
        defaultAccount: 'boolean',
        countryCode: 'string',
        accountIdentifier: 'string',
        bankIdentifier: 'string',
        bankIdentifierType: _validator.struct["enum"](['SORT_CODE', 'SWIFT', 'IBAN', 'ABA', 'ABA_WIRE', 'ABA_ACH'])
      })])
    })
  }));

  var deletePayeeParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    payeeUid: 'uuid'
  }));

  module.exports = Payee;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],10:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.payment = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:payment-service');
  /**
   * Service to interact with a customer's payments
   */

  var Payment = /*#__PURE__*/function () {
    /**
     * Create a new payment service
     * @param {Object} options - configuration parameters
     */
    function Payment(options) {
      _classCallCheck(this, Payment);

      this.options = options;
    }
    /**
     * Get a payment order
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @param {string} parameters.paymentOrderUid - the payment order uid
     * @return {Promise} - the http request promise
     */


    _createClass(Payment, [{
      key: "getPaymentOrder",
      value: function getPaymentOrder(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getPaymentOrderParameterValidator(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken,
            paymentOrderUid = _parameters.paymentOrderUid;
        var url = "".concat(apiUrl, "/api/v2/payments/local/payment-order/").concat(paymentOrderUid);
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a payment order's payments
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.paymentOrderUid - the payment order uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getPaymentOrderPayments",
      value: function getPaymentOrderPayments(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getPaymentOrderPaymentsParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            paymentOrderUid = _parameters2.paymentOrderUid;
        var url = "".concat(apiUrl, "/api/v2/payments/local/payment-order/").concat(paymentOrderUid, "/payments");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * List standing orders
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid of the account to get standing orders of
       * @param {string} parameters.categoryUid - the category uid of the category to get standing orders of
       * @return {Promise} - the http request promise
       */

    }, {
      key: "listStandingOrders",
      value: function listStandingOrders(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        listStandingOrdersParameterValidator(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken,
            accountUid = _parameters3.accountUid,
            categoryUid = _parameters3.categoryUid;
        var url = "".concat(apiUrl, "/api/v2/payments/local/account/").concat(accountUid, "/category/").concat(categoryUid, "/standing-orders");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a standing order
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid of the standing order
       * @param {string} parameters.categoryUid - the category uid of the standing order
       * @param {string} parameters.paymentOrderUid - the payment order uid of the standing order
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getStandingOrder",
      value: function getStandingOrder(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getStandingOrderParameterValidator(parameters);
        var _parameters4 = parameters,
            apiUrl = _parameters4.apiUrl,
            accessToken = _parameters4.accessToken,
            accountUid = _parameters4.accountUid,
            categoryUid = _parameters4.categoryUid,
            paymentOrderUid = _parameters4.paymentOrderUid;
        var url = "".concat(apiUrl, "/api/v2/payments/local/account/").concat(accountUid, "/category/").concat(categoryUid, "/standing-orders/").concat(paymentOrderUid);
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
    }]);

    return Payment;
  }();

  var getPaymentOrderParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    paymentOrderUid: 'uuid'
  }));

  var getPaymentOrderPaymentsParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    paymentOrderUid: 'uuid'
  }));

  var listStandingOrdersParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    categoryUid: 'uuid'
  }));

  var getStandingOrderParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    categoryUid: 'uuid',
    paymentOrderUid: 'uuid'
  }));

  module.exports = Payment;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],11:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["axios", "debug", "../utils/http", "../utils/validator"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("axios"), require("debug"), require("../utils/http"), require("../utils/validator"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.axios, global.debug, global.http, global.validator);
    global.savingsGoal = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_axios, _debug, _http, _validator) {
  "use strict";

  _axios = _interopRequireDefault(_axios);
  _debug = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var log = (0, _debug["default"])('starling:savings-goal-service');
  /**
   * Service to interact with a customer's savings goals
   */

  var SavingsGoal = /*#__PURE__*/function () {
    /**
     * Create a new savings goal service
     * @param {Object} options - configuration parameters
     */
    function SavingsGoal(options) {
      _classCallCheck(this, SavingsGoal);

      this.options = options;
    }
    /**
     * Get all savings goals
     * @param {string} parameters.apiUrl - the API URL
     * @param {string} parameters.accessToken - the oauth bearer token
     * @param {string} parameters.accountUid - the account uid
     * @return {Promise} - the http request promise
     */


    _createClass(SavingsGoal, [{
      key: "getSavingsGoals",
      value: function getSavingsGoals(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getSavingsGoalsParameterValidator(parameters);
        var _parameters = parameters,
            apiUrl = _parameters.apiUrl,
            accessToken = _parameters.accessToken,
            accountUid = _parameters.accountUid;
        var url = "".concat(apiUrl, "/api/v2/account/").concat(accountUid, "/savings-goals");
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Get a savings goal
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.savingsGoalUid - the savings goal's uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "getSavingsGoal",
      value: function getSavingsGoal(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        getSavingsGoalParameterValidator(parameters);
        var _parameters2 = parameters,
            apiUrl = _parameters2.apiUrl,
            accessToken = _parameters2.accessToken,
            accountUid = _parameters2.accountUid,
            savingsGoalUid = _parameters2.savingsGoalUid;
        var url = "".concat(apiUrl, "/api/v2/account/").concat(accountUid, "/savings-goals/").concat(savingsGoalUid);
        log("GET ".concat(url));
        return (0, _axios["default"])({
          method: 'GET',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Create a savings goal
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid of the account to create the savings goal in
       * @param {string} parameters.name - the name of the new savings goal
       * @param {string=} parameters.currency - ISO-4217 3 character currency code
       * @param {number=} parameters.targetAmount - the target amount in minor units (e.g. 1234 => £12.34)
       * @param {string=} parameters.targetCurrency - ISO-4217 3 character currency code
       * @param {string=} parameters.base64EncodedPhoto - base64 encoded image to associate with the goal
       * @return {Promise} - the http request promise
       */

    }, {
      key: "createSavingsGoal",
      value: function createSavingsGoal(parameters) {
        parameters = Object.assign({}, {
          currency: 'GBP',
          targetAmount: 0,
          targetCurrency: 'GBP'
        }, this.options, parameters);
        createSavingsGoalParameterValidator(parameters);
        var _parameters3 = parameters,
            apiUrl = _parameters3.apiUrl,
            accessToken = _parameters3.accessToken,
            accountUid = _parameters3.accountUid,
            name = _parameters3.name,
            currency = _parameters3.currency,
            targetAmount = _parameters3.targetAmount,
            targetCurrency = _parameters3.targetCurrency,
            base64EncodedPhoto = _parameters3.base64EncodedPhoto;
        var url = "".concat(apiUrl, "/api/v2/account/").concat(accountUid, "/savings-goals");
        log("PUT ".concat(url));
        return (0, _axios["default"])({
          method: 'PUT',
          url: url,
          headers: (0, _http.payloadHeaders)(accessToken),
          data: JSON.stringify({
            name: name,
            currency: currency,
            target: {
              minorUnits: targetAmount,
              currency: targetCurrency
            },
            base64EncodedPhoto: base64EncodedPhoto
          })
        });
      }
      /**
       * Delete a savings goal
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.savingsGoalUid - the savings goal's uid
       * @return {Promise} - the http request promise
       */

    }, {
      key: "deleteSavingsGoal",
      value: function deleteSavingsGoal(parameters) {
        parameters = Object.assign({}, this.options, parameters);
        deleteSavingsGoalParameterValidator(parameters);
        var _parameters4 = parameters,
            apiUrl = _parameters4.apiUrl,
            accessToken = _parameters4.accessToken,
            accountUid = _parameters4.accountUid,
            savingsGoalUid = _parameters4.savingsGoalUid;
        var url = "".concat(apiUrl, "/api/v2/account/").concat(accountUid, "/savings-goals/").concat(savingsGoalUid);
        log("DELETE ".concat(url));
        return (0, _axios["default"])({
          method: 'DELETE',
          url: url,
          headers: (0, _http.defaultHeaders)(accessToken)
        });
      }
      /**
       * Add money to a savings goal
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.savingsGoalUid - the savings goal's uid
       * @param {string} parameters.transferUid - a transaction ID for this transaction
       * @param {number} parameters.amount - amount in the minor units of the given currency; eg pence in GBP, cents in EUR
       * @param {string=} parameters.currency - ISO-4217 3 character currency code
       * @return {Promise} - the http request promise
       */

    }, {
      key: "addMoneyToSavingsGoal",
      value: function addMoneyToSavingsGoal(parameters) {
        parameters = Object.assign({}, {
          currency: 'GBP'
        }, this.options, parameters);
        addMoneyToSavingsGoalParameterValidator(parameters);
        var _parameters5 = parameters,
            apiUrl = _parameters5.apiUrl,
            accessToken = _parameters5.accessToken,
            accountUid = _parameters5.accountUid,
            savingsGoalUid = _parameters5.savingsGoalUid,
            transferUid = _parameters5.transferUid,
            amount = _parameters5.amount,
            currency = _parameters5.currency;
        var url = "".concat(apiUrl, "/api/v2/account/").concat(accountUid, "/savings-goals/").concat(savingsGoalUid, "/add-money/").concat(transferUid);
        log("PUT ".concat(url));
        return (0, _axios["default"])({
          method: 'PUT',
          url: url,
          headers: (0, _http.payloadHeaders)(accessToken),
          data: JSON.stringify({
            amount: {
              currency: currency,
              minorUnits: amount
            }
          })
        });
      }
      /**
       * Withdraw money from a savings goal
       * @param {string} parameters.apiUrl - the API URL
       * @param {string} parameters.accessToken - the oauth bearer token
       * @param {string} parameters.accountUid - the account uid
       * @param {string} parameters.savingsGoalUid - the savings goal's uid
       * @param {string} parameters.transferUid - a transaction ID for this transaction
       * @param {number} parameters.amount - amount in the minor units of the given currency; eg pence in GBP, cents in EUR
       * @param {string=} parameters.currency - ISO-4217 3 character currency code
       * @return {Promise} - the http request promise
       */

    }, {
      key: "withdrawMoneyFromSavingsGoal",
      value: function withdrawMoneyFromSavingsGoal(parameters) {
        parameters = Object.assign({}, {
          currency: 'GBP'
        }, this.options, parameters);
        withdrawMoneyFromSavingsGoalParameterValidator(parameters);
        var _parameters6 = parameters,
            apiUrl = _parameters6.apiUrl,
            accessToken = _parameters6.accessToken,
            accountUid = _parameters6.accountUid,
            savingsGoalUid = _parameters6.savingsGoalUid,
            transferUid = _parameters6.transferUid,
            amount = _parameters6.amount,
            currency = _parameters6.currency;
        var url = "".concat(apiUrl, "/api/v2/account/").concat(accountUid, "/savings-goals/").concat(savingsGoalUid, "/withdraw-money/").concat(transferUid);
        log("PUT ".concat(url));
        return (0, _axios["default"])({
          method: 'PUT',
          url: url,
          headers: (0, _http.payloadHeaders)(accessToken),
          data: JSON.stringify({
            amount: {
              currency: currency,
              minorUnits: amount
            }
          })
        });
      }
    }]);

    return SavingsGoal;
  }();

  var getSavingsGoalsParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid'
  }));

  var getSavingsGoalParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    savingsGoalUid: 'uuid'
  }));

  var deleteSavingsGoalParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    savingsGoalUid: 'uuid'
  }));

  var createSavingsGoalParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    name: 'string',
    currency: 'string',
    targetAmount: 'number',
    targetCurrency: 'string',
    base64EncodedPhoto: 'string?'
  }));

  var addMoneyToSavingsGoalParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    savingsGoalUid: 'uuid',
    transferUid: 'uuid',
    amount: 'number',
    currency: 'string'
  }));

  var withdrawMoneyFromSavingsGoalParameterValidator = _validator.struct["interface"](_objectSpread(_objectSpread({}, _validator.minAPIParameterDefintion), {}, {
    accountUid: 'uuid',
    savingsGoalUid: 'uuid',
    transferUid: 'uuid',
    amount: 'number',
    currency: 'string'
  }));

  module.exports = SavingsGoal;
});

},{"../utils/http":13,"../utils/validator":14,"axios":undefined,"debug":undefined}],12:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["./entities/account", "./entities/accountHolder", "./entities/address", "./entities/feedItem", "./entities/card", "./entities/oauth", "./entities/payee", "./entities/payment", "./entities/mandate", "./entities/savingsGoal", "./entities/identity"], factory);
  } else if (typeof exports !== "undefined") {
    factory(require("./entities/account"), require("./entities/accountHolder"), require("./entities/address"), require("./entities/feedItem"), require("./entities/card"), require("./entities/oauth"), require("./entities/payee"), require("./entities/payment"), require("./entities/mandate"), require("./entities/savingsGoal"), require("./entities/identity"));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.account, global.accountHolder, global.address, global.feedItem, global.card, global.oauth, global.payee, global.payment, global.mandate, global.savingsGoal, global.identity);
    global.starling = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_account, _accountHolder, _address, _feedItem, _card, _oauth, _payee, _payment, _mandate, _savingsGoal, _identity) {
  "use strict";

  _account = _interopRequireDefault(_account);
  _accountHolder = _interopRequireDefault(_accountHolder);
  _address = _interopRequireDefault(_address);
  _feedItem = _interopRequireDefault(_feedItem);
  _card = _interopRequireDefault(_card);
  _oauth = _interopRequireDefault(_oauth);
  _payee = _interopRequireDefault(_payee);
  _payment = _interopRequireDefault(_payment);
  _mandate = _interopRequireDefault(_mandate);
  _savingsGoal = _interopRequireDefault(_savingsGoal);
  _identity = _interopRequireDefault(_identity);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * @property {Identity} identity
   * @property {AccountHolder} accountHolder
   * @property {Account} account
   * @property {Address} address
   * @property {FeedItem} feedItem
   * @property {Payment} payment
   * @property {Mandate} mandate
   * @property {Payee} payee
   * @property {Card} card
   * @property {SavingsGoal} savingsGoal
   * @property {OAuth} oAuth
   */
  var Starling =
  /**
   * Create an instance of the starling client
   * @param {Object=} options - configuration parameters
   */
  function Starling(options) {
    _classCallCheck(this, Starling);

    var defaults = {
      apiUrl: 'https://api.starlingbank.com',
      clientId: '',
      clientSecret: ''
    };
    this.config = Object.assign({}, defaults, options);
    this.identity = new _identity["default"](this.config);
    this.accountHolder = new _accountHolder["default"](this.config);
    this.account = new _account["default"](this.config);
    this.address = new _address["default"](this.config);
    this.feedItem = new _feedItem["default"](this.config);
    this.payment = new _payment["default"](this.config);
    this.mandate = new _mandate["default"](this.config);
    this.payee = new _payee["default"](this.config);
    this.card = new _card["default"](this.config);
    this.savingsGoal = new _savingsGoal["default"](this.config);
    this.oAuth = new _oauth["default"](this.config);
  };

  module.exports = Starling;
});

},{"./entities/account":1,"./entities/accountHolder":2,"./entities/address":3,"./entities/card":4,"./entities/feedItem":5,"./entities/identity":6,"./entities/mandate":7,"./entities/oauth":8,"./entities/payee":9,"./entities/payment":10,"./entities/savingsGoal":11}],13:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.http = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.payloadHeaders = _exports.defaultHeaders = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  var defaultHeaders = function defaultHeaders(accessToken) {
    return {
      Accept: 'application/json',
      Authorization: "Bearer ".concat(accessToken)
    };
  };

  _exports.defaultHeaders = defaultHeaders;

  var payloadHeaders = function payloadHeaders(accessToken) {
    return _objectSpread(_objectSpread({}, defaultHeaders(accessToken)), {}, {
      'Content-Type': 'application/json'
    });
  };

  _exports.payloadHeaders = payloadHeaders;
});

},{}],14:[function(require,module,exports){
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.validator = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.minAPIParameterValidator = _exports.minAPIParameterDefintion = _exports.struct = void 0;

  var superstruct = require('superstruct').superstruct;

  var struct = superstruct({
    types: {
      uuid: function uuid(value) {
        return /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
      },
      yearMonth: function yearMonth(value) {
        return /^[0-9]{4}-(?:1[0-2]|0[1-9])$/.test(value);
      },
      date: function date(value) {
        return /^[0-9]{4}-(?:1[0-2]|0[1-9])-(?:3[01]|[12]\d|0[1-9])$/.test(value);
      },
      timestamp: function timestamp(value) {
        return /^((?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z)?$/.test(value);
      }
    }
  });
  _exports.struct = struct;
  var minAPIParameterDefintion = {
    accessToken: 'string',
    apiUrl: 'string'
  };
  _exports.minAPIParameterDefintion = minAPIParameterDefintion;
  var minAPIParameterValidator = struct["interface"](minAPIParameterDefintion);
  _exports.minAPIParameterValidator = minAPIParameterValidator;
});

},{"superstruct":undefined}]},{},[12])(12)
});

//# sourceMappingURL=starling.js.map
